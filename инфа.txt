"The article "TON Connect – The Future Without Passwords" discusses the development and introduction of TON Connect, a technology designed to simplify and secure online logins using a TON wallet. It highlights the inconveniences of traditional password-based systems, such as the need for manual entry, susceptibility to loss or theft, and privacy concerns related to sharing personal information like emails or phone numbers.

TON Connect aims to solve these issues by allowing users to log into services and applications with a single click using their TON wallet, without needing to remember passwords or compromising their privacy. The secret key remains on the user's device, and services gain access to blockchain functionalities like cryptocurrency payments.

Initially developed by Tonkeeper, TON Connect has become a network-wide standard, supported by all popular TON wallets and integrated into various ton.org services. This has created a unified connection method for services and wallets across different platforms, a significant achievement compared to other blockchain networks that often have a fragmented approach. The article also mentions the development of TON Connect UI to ensure a consistent user experience.

Furthermore, the article addresses the decision not to adopt existing multi-network technologies like WalletConnect, citing TON's commitment to decentralization. Unlike WalletConnect's centralized server model, TON Connect allows wallet developers to launch their own servers, offering greater adaptation to The Open Network.

For websites not yet integrated with TON Connect, a password manager feature has been introduced directly into TON wallets, starting with MyTonWallet. This feature automatically generates secure, encrypted passwords based on the TON wallet's private key. The article concludes by emphasizing TON's belief that blockchain technologies should improve user experience, with TON Connect serving as a prime example of making familiar online interactions simpler, more convenient, and safer."

"Engage and grow your community with exclusive Telegram native Web3 tools. The TON Foundation invites creators and communities to utilize the TON-Telegram Web3 ecosystem.

You can start by using TON-based tools on Telegram, such as launching a simple Mini App to increase engagement. Many creators have already built Telegram mini apps with engaging mechanics, leading to higher engagement and value capture.

Wallet can be used as an ultimate window to Web3, allowing users to hold, buy, sell, send, and receive crypto P2P inside Telegram. You can also integrate crypto payments into your Mini Apps with Wallet Pay.

Monetize your Telegram audience with Tribute, a tool that allows creators to provide exclusive content and accept subscriptions or donations in crypto. Users will also earn a 3% crypto cashback.

Grow your community through exciting quests and SBTs (Soulbound Tokens), which are unique on-chain badges proving a user completed an action on your project. Campaigns can be launched on Quest Platforms like GemsWall, Intract, TBook, BroBot Contests, and JVault.

Empower your community with a token, memecoin, or NFT collection by exploring TON platforms for launches such as TON Raffles, TonUp, JVault, Tonstarter, and DYOR. NFT marketplaces like Getgems, xRare, and TON Diamonds are also available, along with TON Memelandia as a cultural hub.

Finally, you can earn on referral and ambassador programs by exploring TON projects like xRocket, Storm Trade, and STON.fi. The page also provides options to choose your language and lists various resources for users, builders, and community engagement, including documentation, developer forums, job opportunities, and information on TON's concept, roadmap, and sustainability."

"The article is about how to run TON (The Open Network) Sites.

It explains that TON Sites work similarly to regular websites but require additional steps to start. The guide walks you through the setup process, which involves installing the Tonutils reverse proxy to use TON Proxy for your website. You can run the proxy with or without a domain. If the setup is successful, your site will be available at the ADNL address generated during the configuration."

Set up TON SDK

Download the SDK for the most convenient language to develop on TON.

Get started with TON
Discover the speed, reliability, and core principles of asynchronous thinking by building your first application on the TON blockchain — from scratch.

newcomer-friendly guide
This is the perfect place to start if you're entirely new to programming.

This learning path is split into 5 beginner-friendly modules and takes approximately 45 minutes.

What you will learn
In this step-by-step guide, you'll learn how to create and interact with the TON blockchain applications using JavaScript. While it's possible to figure it out independently, this path offers a faster, smoother experience — especially if you're starting.

Here's what you'll do:

Create your TON wallet using Tonkeeper.
Use a Testnet faucet to top up your wallet with test tokens.
Learn key smart contract concepts like addresses and cells.
Interact with the TON blockchain using the TypeScript SDK and an API provider.
Compile and send your first transaction using the NFT Miner console app.
You're about to mine your first NFT rocket achievement! As one of the first TON explorers, you'll complete a Proof-of-work smart contract and unlock a hidden reward for your wallet. Let's dive in:

Our goal for today is to mine an NFT! This achievement will stay with you forever.

Finally, you can mine this NFT achievement even in the Mainnet. (it costs only 0,05 TON!).

Mining on TON Blockchain
Today, we are going to teach our prospective builders how to mine on TON Blockchain. This experience helps you understand the significance of mining and why Bitcoin mining helped revolutionize the industry.

Although the proof-of-work giver smart contract framework, which defined the initial mining process that laid the foundation for TON, was completed at launch, the last TON was mined in June 2022 to conclude TON's proof-of-work (PoW) token distribution mechanism. That said, with our recent transition to proof-of-stake (PoS), the era of staking on TON has just begun.

Dive deeper into our economic model and mining on TON
Now, let’s focus on the first steps to becoming a TON Developer and learn how to mine an NFT on TON! Below is an example of what we're aiming to create.

If we stay focused on the task at hand, we can create a miner in about half an hour.

Getting started
To get started, all developers will make use of the following components:

Wallet: You need a non-custodial wallet to store an NFT in Testnet mode.
Repository: We’ll use a ready-made template designed specifically for you.
Developer Environment: Developers need to determine whether they want to mine in a local or cloud environment.
Download and create a wallet
First, you need a non-custodial wallet to receive and store your TON. For this guide, we are using Tonkeeper. You need to enable Testnet mode within the wallet to receive Testnet TON coins. These tokens will be used later to send a final minting transaction to the smart contract.

info
With a non-custodial wallet, the user owns the wallet and holds the private key themselves.

To download and create a TON wallet, follow these simple steps:

Install the Tonkeeper app on your smartphone. It can be downloaded here.
Next, you need to enable test mode within Tonkeeper.
Easy! Let's go to the development now.

Project setup
We use a boilerplate to simplify your life and skip routine low-level tasks.

tip
Note that you need to sign in to GitHub for further work.

Please use the ton-onboarding-challenge template to create your project by clicking the “Use this template” button and selecting the “Create a new repository” tab as shown below:



After completing this step, you'll have access to a highly performant repository that can serve as your miner's core. Congratulations!

Development environments
The next step is to choose which developer environment best suits your needs, experience level, and overall skill set. As you can see, this process can be carried out using either a cloud-based or local environment. Developing on the cloud is often considered simpler and easier to get started. Below, we’ll outline the steps required for both approaches.

tip
Ensure you have opened the repository in your GitHub profile generated from the template in the previous step.



Local and cloud development environments
Using a Javascript IDE can be challenging for users unfamiliar with it, especially if your computer and tooling systems are not configured for this purpose.

However, if you're familiar with NodeJS and Git and know how to work with npm, you may find it more comfortable to use a local environment.

Cloud codespaces
If you choose the cloud development environment, it's easy to get started by first selecting the Code tab and then by clicking on the Create codespace on master button within the GitHub repository shown below:



After completing this step, GitHub will create a special cloud workspace that allows you to access the VSCode Online IDE (Visual Studio Code Online Integrated Development Environment).

Once access is granted (the codespace typically starts in about 30 seconds), you have everything required to begin without installing Git, Node.js, or other developer tools.

Local development environments
To set up a local development environment, you require access to these three essential tools:

Git: Git is an essential tool for every developer working with repositories. It can be downloaded here.
NodeJS: Node.js is the JavaScript and TypeScript runtime environment typically used for application development on TON. It can be downloaded here.
JavaScript IDE. JavaScript IDE’s are typically used for development within local development environments. An example of this case is Visual Studio Code (VSCode).
To get started, you need to clone your GitHub repository boilerplate and open the correct repository in your Integrated Development Environment (IDE).

Running scripts
In this guide, you'll need to run TypeScript scripts. All commands, such as running scripts or installing modules, are executed through the command line, which is located in the IDE's Terminal workspace, which is typically found at the bottom of the IDE.

For example, in the Cloud Codespaces, you should open the Terminal workspace if it is not already open:




Enter commands in this window and execute them with Enter:




The terminal is also available as a separate application. Please choose the appropriate version based on your IDE and OS.

Great! After these steps, you're ready to get deeper into TON Blockchain secrets.

Connect to TON
Okay, what do you need to connect to TON Blockchain?

Smart contract address as a point of destination. We aim to mine an NFT from the proof-of-work smart contract, so we need an address to determine the current mining complexity.
API provider to make requests to TON Blockchain. TON has multiple API types for different purposes. We will use the testnet version of toncenter.com API.
JavaScript SDK: a JavaScript SDK (recall that an SDK is a Software Development Kit) is needed to parse the smart contract address used and prepare it to create an API request. To better understand TON addresses and why they need to be parsed to carry out this process, please see this resource to understand why we should parse it. To carry out this procedure, we use @ton/ton.
In the next section, we describe how users send their initial requests to TON Blockchain using the TON Center API and @ton/ton to receive data from the PoW smart contract.

Smart contract addresses
For the miner to work correctly, we need to add two different smart contract address types. These include:

Wallet address: a wallet address is required for the miner to receive their mining reward (in this case, we must use the Tonkeeper Testnet mode).
Collection address: a collection address is required to act as a smart contract to correctly mine an NFT (to carry out this process, copy the NFT collection address under the TON onboarding challenge collection name from the Getgems website).
Next, we open the ./scripts/mine.ts file in your miner and create a mine() function composed of initial constants as follows:

./scripts/mine.ts
import {Address} from '@ton/ton';

const walletAddress = Address.parse('YOUR_WALLET_ADDRESS');
const collectionAddress = Address.parse('COLLECTION_ADDRESS');

async function mine () {


}

mine();

Using the async mine() function
Later, when creating a TON NFT Miner, several requests will be executed to the public API to relay responses to the correct code string in exchange for the desired instructions. Leveraging the async/await function dramatically improves code simplicity.

Address parsing
On TON, smart contract addresses come in different forms that employ numerous flag types. In this context specifically, we use the user-friendly address form. If you are curious to learn more about the different smart contract address types, feel free to check out this additional resource in our documentation.

For the miner to work correctly, we need to add two different smart contract address types. These include:

The Address.parse() method located in the @ton/ton SDK allows the developer to create an address object to convert addresses from one form to another in a simplified manner.

Connect to an API provider
In this step, we'll connect with TON via TON Center, which is hosted on the toncenter.com API provider, using specific commands in the script.

The simplest way to do it is by specifying the Testnet endpoint https://testnet.toncenter.com/api/v2/jsonRPC.



We add client and endpoint in the ./scripts/mine.ts script using TonClient and Testnet TON Center endpoint https://testnet.toncenter.com/api/v2/jsonRPC:

./scripts/mine.ts
import {Address, TonClient} from "@ton/ton"

// ... previous code

// specify endpoint for Testnet
const endpoint = "https://testnet.toncenter.com/api/v2/jsonRPC"

// initialize ton library
const client = new TonClient({ endpoint });

what to do in production?
Using an RPC node provider or running your own ton-http-api instance is better for that. Read more at the TON Center API page.

Receiving mining data from TON Blockchain
Finally, the next step in the process is to retrieve specific mining data from TON Blockchain.

By consulting the README file needed to complete the TON onboarding challenge, the latest TON mining data is obtained by running the get_mining_data method. Once initiated, the result will be as follows:

As a result, we should receive an array with these fields:

(
	int pow_complexity,
	int last_success,
	int seed,
	int target_delta,
	int min_cpl,
	int max_cpl
)

Running smart contract get methods on TON
Using @ton/ton is possible to run the client.runMethod(SMART_CONTRACT_ADDRESS, METHOD) function. Running this code will result in the following console output:

./scripts/mine.ts
// ... previous code

const miningData = await client.runMethod(collectionAddress, 'get_mining_data');

console.log(miningData.stack);


Furthermore, to run the script, it is necessary to enter the following command in the terminal:

npm run start:script

tip
To avoid unexpected issues, ensure you have finalized all previous steps, including inputting contract addresses.

Good! As long as the above processes are executed correctly, a successful connection to the API will be achieved, and the necessary data will be displayed in the console. The correct console output should be initiated as follows:

TupleReader {
  items: [
    {
      type: 'int',
      value: 7237005577332262213973186563042994240829374041602535252466099000494570602496n
    },
    { type: 'int', value: 1730818693n },
    { type: 'int', value: 281644526620911853868912633959724884177n },
    { type: 'int', value: 30n },
    { type: 'int', value: 171n },
    { type: 'int', value: 252n }
  ]
}



The output above shows data on executing a process with a collection of numerical (int) values. The current focus is to convert this numerical output into a more practical format.

We need to convert the hex output to something useful.

GAS PARAMETERS ON TON
Warning: Though this information is highly complex and not necessary for this tutorial if you're interested in understanding the complex technical aspects of TON, consider using these resources:

To better understand how TON Virtual Machine (TVM) operates and how TON processes transactions, check out TVM overview section.
Secondly, if you want to learn more about how transaction and gas fees work on TON, consider diving into this section of our documentation.
Finally, to better understand the exact gas values needed to carry out TVM instructions, see this section of our documentation.
Now, let's return to the tutorial!

Numerical mining data in a user-friendly format
In the section above, we discuss numerical (int) values needed to receive mining data. Before processing, further received data must be converted into a more easily understandable and usable format.

As it is clear when examining the given output, numbers can be substantial. We will use bigint (the big number implementation in JavaScript) to deal with them. BigInt works with large numbers that are more significant than the maximum number integer values. Let’s use this example to get a better idea of the Mining Data required for this process:

./scripts/mine.ts
// ... previous code

const { stack } = miningData;

const complexity = stack.readBigNumber();
const lastSuccess = stack.readBigNumber();
const seed = stack.readBigNumber();
const targetDelta = stack.readBigNumber();
const minCpl = stack.readBigNumber();
const maxCpl = stack.readBigNumber();

console.log({ complexity, lastSuccess, seed, targetDelta, minCpl, maxCpl });


As shown above, the different components of miningData use stack-based numbers for different parameters, which will be introduced in the section below. To achieve the desired value outcome, we used the stack.readBigNumber() function to read a bigint from the stack.

After this process is complete, we may print values to the console. Try to run the script again by running the command:

npm run start:script

Here is an example output:

{
  complexity: 7237005577332262213973186563042994240829374041602535252466099000494570602496n,
  lastSuccess: 1730818693n,
  seed: 281644526620911853868912633959724884177n,
  targetDelta: 30n,
  minCpl: 171n,
  maxCpl: 252n
}


Let's cover the Mining Data command that translates different data parameters when programming mining data into TON Blockchain. These include:

complexity is the most important number for miners. It's a Proof-of-Work complexity for the values. You're successful if the final hash is less than complexity.
lastSuccess is a unix timestamp date and time representation that keeps track of the last mining transaction on TON. Each time the last_success metric changes, it's necessary to rerun the miner because the seed also changes during this process.
seed denotes a unique value a smart contract generates to calculate the desired hash. To better understand this process and learn more about how the seed changes and why, look at the project files folder using the ctx_seed keyword (Ctrl+F with the keyword ctx_seed).
targetDelta, minCpl and maxCpl won't be used in our tutorial. But you can always read more about how they are used in smart contracts to calculate proof-of-work complexity in the source files of the collection in your project.
Now that we understand the parameters discussed above, we have the values(complexity, lastSuccess, seed) that we will use in our NFT Miner in the next chapter.

Prepare an NFT miner
Hey, you're doing a great job!

After connecting to TON and retrieving the necessary mining data from the blockchain to create an NFT miner, let's focus on the next steps in this process to achieve our goal.

In this chapter, you will prepare a mining message and calculate a hash of the message. After that, you will find a hash that's less(<) than the complexity we got from the smart contract.

That is what a miner is! Simple, isn't it?

Preparing mining messages
First, we must prepare a mining message by ensuring the correct parameters to ensure this process's validity and data integrity.

Thankfully, the README file allows us to retrieve the correct guidelines to achieve this goal. As you can see, the above README file comprises a table with specific fields and cell types (titled "Layout of proof of work cell') to help achieve our desired result.

What are cells?
Cells are data storage structures on TON that fulfill numerous purposes, including increasing network scalability and smart contract transaction speeds. We won't get into specifics here, but if you're interested in understanding the complexity of cells and how they work, consider diving into this section of our documentation.

Fortunately, all the data structures used in this tutorial are already written in TypeScript. Use the MineMessageParams object from NftGiver.data.ts to build a transaction with Queries:

./scripts/mine.ts
import { unixNow } from '../lib/utils';
import { MineMessageParams, Queries } from '../wrappers/NftGiver';

// ... previous code

const mineParams: MineMessageParams = {
    expire: unixNow() + 300, // 5 min is enough to make a transaction
    mintTo: walletAddress, // your wallet
    data1: 0n, // temp variable to increment in the miner
    seed // unique seed from get_mining_data
};

let msg = Queries.mine(mineParams); // transaction builder

Probably you have a question: where are the op and data2 from the table?

In the table, the numerical value of data1 must equal that of data2. To omit the filling of the data2 value, the transaction builder performs a low-level process (see Queries.mine() sources).
Because the op classification is always constant, it is already implemented in transaction builder Queries and in OpCodes. You can find the opcode by going to the source code of the mine() method.
tip
Though it may be interesting to check out the source code (../wrappers/NftGiver.ts), but it is unnecessary.

Creating TON NFT miners
Now that we have completed the process to prepare messages for our TON miner, let’s jump into the initial process to create a miner. First, let’s consider this line of code:

let msg = Queries.mine(mineParams);

Above, we compiled a msg value. The idea of mining is to find a hash msg.hash() that will be less than complexity from the last received get_mining_data(). We can increment data1 as many times as we need.

The pure miner will continue to run indefinitely if msg.hash() is bigger than complexity (message hash is larger than PoW mining complexity).

Here is an example of the code running as it relates to BigInt in TypeScript:

./scripts/mine.ts
let msg = Queries.mine(mineParams);

const bufferToBigint = (buffer: Buffer) => BigInt('0x' + buffer.toString('hex'));

while (bufferToBigint(msg.hash()) > complexity) {
    mineParams.expire = unixNow() + 300;
    mineParams.data1 += 1n;
    msg = Queries.mine(mineParams);
}

console.log('Yoo-hoo, you found something!');


We convert the hash from the msg.hash() to bigint with the bufferToBigint() function. This is done to use this hash in comparison with complexity.

Though the miner will work properly after completing the above steps, it will have a visually unappealing appearance (try npm run start:script). Therefore, we must address this issue. Let’s jump in.

Improving TON miner appearance
We want to make the miner look sexy now! How do we do it?

Just follow me, my friend, follow me.

To achieve our goal, we’ll add these commands:

./scripts/mine.ts
let msg = Queries.mine(mineParams); // transaction builder
let progress = 0;

const bufferToBigint = (buffer: Buffer) => BigInt('0x' + buffer.toString('hex'));

while (bufferToBigint(msg.hash()) > complexity) {
    console.clear()
    console.log(`Mining started: please, wait for 30-60 seconds to mine your NFT!`)
    console.log()
    console.log(`⛏ Mined ${progress} hashes! Last: `, bufferToBigint(msg.hash()))

    mineParams.expire = unixNow() + 300;
    mineParams.data1 += 1n;
    msg = Queries.mine(mineParams);
}

console.log()
console.log('💎 Mission completed: msg_hash less than pow_complexity found!');
console.log()
console.log('msg_hash:       ', bufferToBigint(msg.hash()))
console.log('pow_complexity: ', complexity)
console.log('msg_hash < pow_complexity: ', bufferToBigint(msg.hash()) < complexity);

return msg;


Just check it out! Let’s execute the command:

npm run start:script



Cool, isn't it?

After executing these commands correctly, we'll have a visually appealing NFT miner. In the next section, we'll focus on connecting a wallet to the miner to create a payment channel that accepts and receives transactions from TON Blockchain.

Prepare a transaction
Next, we'll outline the steps to compile a message and send it to the blockchain with your Tonkeeper wallet. The upcoming steps will guide you in completing the process of mining an NFT on TON.

Top up wallet balance via the token faucet
We need to acquire some TON Testnet tokens to proceed to the next step. This can be achieved using the Testnet faucet found here.

Leverage Blueprint transaction opportunities
To ensure that the NFT mining process is carried out correctly and that the user can store their NFT properly, we will use Blueprint to simultaneously interact with TON Blockchain and the Tonkeeper wallet.

To achieve this goal, we'll use the standard run() function to run to the creation of the transaction and send it:

./scripts/mine.ts
import { toNano } from '@ton/ton';
import { NetworkProvider } from '@ton/blueprint';

async function mine() {
  // code from previous steps
}

export async function run(provider: NetworkProvider) {
    // Do not forget to return `msg` from `mine()` function
    const msg = await mine();

    await provider.sender().send({
        to: collectionAddress,
        value: toNano(0.05),
        body: msg
    });
}

Let’s run the above script to send transaction:

npm start

Note that we use npm start instead of npm run start:script. This is because we need to leverage the advantages of the blueprint (under the hood, blueprint run is called).

After running this command, answer the questions as shown below to connect your Tonkeeper wallet:

? Which network do you want to use?
> testnet
? Which wallet are you using?
> TON Connect compatible mobile wallet (example: Tonkeeper)
? Choose your wallet (Use arrow keys)
> Tonkeeper

Scan the QR code shown in the terminal with your Tonkeeper wallet to establish a connection; no transaction has been sent yet. Once connected, confirm the transaction in Tonkeeper.

Do you sense the experience in the air? That's you on your way to becoming a TON developer.

Mine NFT with a wallet
There are two main ways to mine an NFT on TON:

Simple: NFT Testnet Mining
Genuine: NFT Mainnet Mining
Simple: NFT Testnet mining
Below are the steps needed to initiate your first Testnet transaction to mine your NFT:

Activate Testnet mode within your Tonkeeper wallet
Input our Testnet wallet address from Tonkeeper into the walletAddress variable in the ./scripts/mine.ts.
Input address of the NFT collection from Testnet into collectionAddress variable in the ./scripts/mine.ts.
Mine a Testnet NFT rocket
To successfully mine an NFT rocket on Testnet, it is necessary to follow these steps:

Open the Tonkeeper wallet on your phone (it should hold some newly received TON Testnet tokens).
Select scan mode in the wallet to scan the QR code.
Run your miner to acquire the correct hash (this process takes between 30 and 60 seconds).
Follow the steps in the Blueprint dialogue.
Scan the generated QR code from the miner.
Confirm the transaction in your Tonkeeper wallet.
final tip
Because other developers may be carrying out the same process in an attempt to mine their own NFT, you may need to try the process a couple of times to succeed, as another user could mine the next NFT available right before you.

Soon after initiating this process, you will have successfully mined your first NFT on TON, and it should appear in your Tonkeeper wallet.



Welcome aboard, a true TON Developer! You did it.

Genuine: NFT Mainnet mining
Hey! For those who wish to mine an NFT on TON Mainnet, these instructions should be followed:

You have activated Mainnet mode in your Tonkeeper (it should hold at least 0.1 TON).
Input our Mainnet wallet address from Tonkeeper into the walletAddress variable in the ./scripts/mine.ts
Input address of the NFT collection from the Mainnet into collectionAddress variable in the ./scripts/mine.ts
Replace endpoint to the Mainnet:
./scripts/mine.ts
// specify endpoint for Mainnet
const endpoint = "https://toncenter.com/api/v2/jsonRPC"

Mine a Mainnet NFT rocket
As we outlined in the Testnet NFT rocket mining process, to successfully mine an NFT rocket on the Mainnet, it is necessary to follow these steps:

Open the Tonkeeper wallet on your phone (remember, it should hold some TON tokens).
Select scan mode in the wallet to scan the QR code.
Run your miner to acquire the correct hash (this process takes between 30 and 60 seconds).
Follow the steps in the Blueprint dialogue.
Scan the generated QR code from the miner.
Confirm the transaction in your Tonkeeper wallet.
final tip
Because other developers may be carrying out the same process to mine their own NFT, you may have to try the process a couple of times to be successful (as another user could mine the next NFT available right before you).

After some time, you will have mined your NFT and become a TON Developer in TON Blockchain. The ritual is complete. Look at your NFT in Tonkeeper.

Welcome aboard, a TON Developer! You did it.

TON Hello World part 1: Step by step guide for working with your first TON wallet

by Tal Kol
 
TON Blockchain is based on the TON coin (previously labeled TonCoin). This cryptocurrency is used to pay for executing transactions (gas), much like ETH on the Ethereum blockchain. If you're participating in the TON ecosystem, most likely that you're already holding some TON and probably already have a wallet.

In this step by step tutorial, we will create a new TON wallet using one of the wallet apps and then try to access it programmatically. This can be useful for example if you're planning on deploying a smart contract through code or writing a bot that receives and sends TON. We'll also understand how wallets work on TON and become comfortable with using them.

Mainnet or testnet
There are two variations of TON Blockchain we can work on - mainnet and testnet. Mainnet is the real thing, where we would have to pay real TON coin in order to transact and staked validators would execute our transactions and guarantee a very high level of security - our wallet would be able to do dangerous things like holding large amounts of money without worrying too much.

Testnet is a testing playground where the TON coin isn't real and is available for free. Naturally, testnet doesn't offer any real security so we would just use it to practice and see that our code is behaving as expected.

Testnet is often appealing to new developers because it's free, but experience shows that mainnet is actually more cost effective. Since testnet is a simulated environment, it requires special wallets, doesn't always behave like the real thing and is more prone to flakiness and random errors.

Since TON transactions are very cheap, about 1 cent per transaction, investing just $5 will be enough for hundreds of transactions. If you decide to work on mainnet you will have a significantly smoother experience. The time you save will definitely be worth more than the $5 you spent.

Step 1: Create a new wallet using an app
The simplest way to create a TON wallet is visit https://ton.org/wallets and choose one of the wallet apps from the list. This page explains the difference between custodial and non-custodial wallets. With a non-custodial wallet, you own the wallet and hold its private key by yourself. With a custodial wallet, you trust somebody else to do this for you.

The point of blockchain is being in control of your own funds, so we'll naturally choose a non-custodial option. They're all pretty similar, let's choose Tonkeeper. Go ahead and install the Tonkeeper app on your phone and run it.

Tonkeeper works by default on TON mainnet. If you decided to work on testnet, you will need to switch the app manually to dev mode. Open the "Settings" tab and tap 5 times quickly on the Tonkeeper Logo on the bottom. The "Dev Menu" should show up. Click on "Switch to Testnet" and make the switch. You can use this menu later to return to mainnet.

If you don't already have a wallet connected to the app, tap on the "Set up wallet" button. We're going to create a new wallet. After a few seconds, your wallet is created and Tonkeeper displays your recovery phrase - the secret 24 words that give access to your wallet funds.

Step 2: Backup the 24 word recovery phrase
The recovery phrase is the key to accessing your wallet. Lose this phrase and you'll lose access to your funds. Give this phrase to somebody and they'll be able to take your funds. Keep this secret and backed up in a safe place.

Why 24 words? The OG crypto wallets, like Bitcoin in its early days, did not use word phrases, they used a bunch of random looking letters to specify your key. This didn't work so well because of typos. People would make a mistake with a single letter and not be able to access their funds. The idea behind words was to eliminate these mistakes and make the key easier to write down. These phrases are also called "mnemonics" because they act as mnemonic devices that make remembering them easier for humans.

Step 3: View the wallet by address in an explorer
If you click on the top left in the Tonkeeper app you will copy your wallet address. Alternatively, you can tap on the "Receive" button and see your wallet address displayed on screen.

It should look something like this:

copied!
kQCJRglfvsQzAIF0UAhkYH6zkdGPFxVNYMH1nPTN_UpDqEFK
This wallet address isn't secret. You can share it with anyone you want and they won't be able to touch your funds. If you want anyone to send you some TON, you will need to give them this address. You should be aware though of some privacy matters. Wallet addresses in TON and most blockchains are pseudo-anonymous, this means that they don't reveal your identity in the real world. If you tell somebody your address and they know you in the real world, they can now make the connection.

An explorer is a tool that allows you to query data from the chain and investigate TON addresses. There are many explorers to choose from. We're going to use Tonscan. Notice that mainnet and testnet have different explorers because those are different blockchains.

The testnet version of Tonscan is available on https://testnet.tonscan.org - open it and input your wallet address.

If this wallet is indeed new and hasn't been used before, its Tonscan page should show "State" as "Inactive". When you look under the "Contract" tab, you should see the message "This address doesn't contain any data in blockchain - it was either never used or the contract was deleted."



Wallets in TON are also smart contracts! What this message means is that this smart contract hasn't been deployed yet and is therefore uninitialized. Deploying a smart contract means uploading its code onto the blockchain.

Another interesting thing to notice is that the address shown in Tonscan may be different from the address you typed in the search bar! There are multiple ways to encode the same TON address. You can use https://ton.org/address to see some additional representations and verify that they all share the same HEX public key.

Step 4: Fund and deploy your wallet contract
As you can see in the explorer, the TON balance of our wallet is currently zero. We will need to fund our wallet by asking somebody to transfer some TON coins to our address. But wait… isn't this dangerous? How can we transfer some coins to the smart contract before it is deployed?

It turns out that this isn't a problem on TON. TON Blockchain maintains a list of accounts by address and stores the TON coin balance per address. Since our wallet smart contract has an address, it can have a balance, even before it has been deployed. Let's send 2 TON to our wallet address.

When using testnet, TON coins can be received for free. Using Telegram messenger, open the faucet https://t.me/testgiver_ton_bot and request some coins from the bot by providing your wallet address.

Refresh the explorer after the coins have been sent. As you can see, the balance of the smart contract is now 2 TON. And the "State" remains "Inactive", meaning it still hasn't been deployed.



So when is your wallet smart contract being deployed? This would normally happen when you execute your first transaction - normally an outgoing transfer. This transaction is going to cost gas, so your balance cannot be zero to make it. Tonkeeper is going to deploy our smart contract automatically when we issue the first transfer.

Let's send 0.01 TON somewhere through Tonkeeper.

Refresh the explorer after approving the transaction. We can see that Tonkeeper indeed deployed our contract! The "State" is now "Active". The contract is no longer uninitialized and shows "wallet v4 r2" instead. Your contract may show a different version if Tonkeeper was updated since this tutorial was written.



We can also see that we've also paid some gas for the deployment and transfer fees. After sending 0.01 TON we have 1.9764 TON remaining, meaning we paid a total of 0.0136 TON in fees, not too bad.

Step 5: Wallets contracts have versions
The explorer shows that "Contract Type" is "wallet v4 r2" (or possibly a different version if your Tonkeeper was since updated). This refers to the version of our smart contract code. If our wallet smart contract was deployed with "v4" as its code, this means somewhere must exist "v1", "v2" and "v3".

This is indeed correct. Over time, the TON core team has published multiple versions of the wallet contract - this is v4 source code.

Let's look at this well known wallet address of TON Foundation. As you can see, it uses "wallet v3 r2" for its code. It was probably deployed before v4 was released.



Is it possible for the same secret mnemonic to have multiple wallets deployed with different versions? Definitely! This means that the same user may have multiple different wallets, each with its own unique address. This can get confusing. The next time you try to access your wallet using your secret mnemonic and you see a different address than you expect and a balance of zero, don't be alarmed. Nobody stole your money, you are probably just looking at the wrong wallet version.

Step 6: Set up your local machine for coding
We're about to use code to access our wallet programmatically. Before we can start writing code, we need to install certain developer tools on our computer.

The libraries we're going to rely on are implemented in JavaScript. Accordingly, our scripts will be executed by an engine called Nodejs. The installation instructions are here. We will need a fairly recent version of node like v16 or v17. You can verify your nodejs version by running node -v in terminal.

For a choice of IDE, you will need anything that has decent TypeScript support. I recommend Visual Studio Code - it's free and open source.

Let's create a new directory for our project and support TypeScript. Open terminal in the project directory and run the following:

copied!
npm install typescript ts-node
Next, we're going to initialize Typescript project:

copied!
npx tsc --init
Next, we're going to install a JavaScript package named @ton/ton that will allow us to make TON API calls and manipulate TON objects. Install the package by opening terminal in the project directory and running:

copied!
npm install @ton/ton @ton/crypto @ton/core
Step 7: Get the wallet address programmatically
The first thing we'll do is calculate the address of our wallet in code and see that it matches what we saw in the explorer. This action is completely offline since the wallet address is derived from the version of the wallet and the private key used to create it.

Let's assume that your secret 24 word mnemonic is unfold sugar water ... - this is the phrase we backed up in step 2.

Create the file step7.ts with the following content:

copied!
import { mnemonicToWalletKey } from "@ton/crypto";
import { WalletContractV4 } from "@ton/ton";

async function main() {
  // open wallet v4 (notice the correct wallet version here)
  const mnemonic = "unfold sugar water ..."; // your 24 secret words (replace ... with the rest of the words)
  const key = await mnemonicToWalletKey(mnemonic.split(" "));
  const wallet = WalletContractV4.create({ publicKey: key.publicKey, workchain: 0 });

  // print wallet address
  console.log(wallet.address.toString({ testOnly: true }));

  // print wallet workchain
  console.log("workchain:", wallet.address.workChain);
}

main();
To see the wallet address, run it using terminal:

copied!
npx ts-node step7.ts
Notice that we're not just printing the address, we're also printing the workchain number. TON supports multiple parallel blockchain instances called workchains. Today, only two workchains exist, workchain 0 is used for all of our regular contracts, and workchain -1 (the masterchain) is used by the validators. Unless you're doing something special, you'll always use workchain 0.

As discussed in step 5, if your wallet has a different version from "wallet v4 r2" you will need to modify slightly the code above. Let's say for example that your version is "wallet v3 r2", then replace WalletContractV4 with WalletContractV3R2.

Step 8: Read wallet state from the chain
Let's take things up a notch and read some live state data from our wallet contract that will force us to connect to the live blockchain network. We're going to read the live wallet TON coin balance (we saw that on the explorer earlier). We're also going to read the wallet seqno - the sequence number of the last transaction that the wallet sent. Every time the wallet sends a transaction the seqno increments.

To query info from the live network will require an RPC service provider - similar to Infura on Ethereum. These providers run TON Blockchain nodes and allow us to communicate with them over HTTP. TON Access is an awesome service that will provide us with unthrottled API access for free. It's also decentralized, which is the preferred way to access the network.

Install it by opening terminal in the project directory and running:

copied!
npm install @orbs-network/ton-access
Create the file step8.ts with the following content:

copied!
import { getHttpEndpoint } from "@orbs-network/ton-access";
import { mnemonicToWalletKey } from "@ton/crypto";
import { WalletContractV4, TonClient, fromNano } from "@ton/ton";

async function main() {
  // open wallet v4 (notice the correct wallet version here)
  const mnemonic = "unfold sugar water ..."; // your 24 secret words (replace ... with the rest of the words)
  const key = await mnemonicToWalletKey(mnemonic.split(" "));
  const wallet = WalletContractV4.create({ publicKey: key.publicKey, workchain: 0 });

  // initialize ton rpc client on testnet
  const endpoint = await getHttpEndpoint({ network: "testnet" });
  const client = new TonClient({ endpoint });

  // query balance from chain
  const balance = await client.getBalance(wallet.address);
  console.log("balance:", fromNano(balance));

  // query seqno from chain
  const walletContract = client.open(wallet);
  const seqno = await walletContract.getSeqno();
  console.log("seqno:", seqno);
}

main();
To see the balance and seqno, run using terminal:

copied!
npx ts-node step8.ts
If you have network connectivity issues and get errors like backend nodes unhealthy or timeouts, please join the Telegram support chat for TON access to get assistance.

Step 9: Send transfer transaction to the chain
The previous action was read-only and should generally be possible even if you don't have the private key of the wallet. Now, we're going to transfer some TON from the wallet. Since this is a privileged write action, the private key is required.

Reward: We will send 0.05 TON to the special address to mint a secret NFT from "TON Masters" collection (testnet link). Here is how your reward looks like:

Create a new file step9.ts with this content:

copied!
import { getHttpEndpoint } from "@orbs-network/ton-access";
import { mnemonicToWalletKey } from "@ton/crypto";
import { TonClient, WalletContractV4, internal } from "@ton/ton";

async function main() {
  // open wallet v4 (notice the correct wallet version here)
  const mnemonic = "unfold sugar water ..."; // your 24 secret words (replace ... with the rest of the words)
  const key = await mnemonicToWalletKey(mnemonic.split(" "));
  const wallet = WalletContractV4.create({ publicKey: key.publicKey, workchain: 0 });

  // initialize ton rpc client on testnet
  const endpoint = await getHttpEndpoint({ network: "testnet" });
  const client = new TonClient({ endpoint });

  // make sure wallet is deployed
  if (!await client.isContractDeployed(wallet.address)) {
    return console.log("wallet is not deployed");
  }

  // send 0.05 TON to EQA4V9tF4lY2S_J-sEQR7aUj9IwW-Ou2vJQlCn--2DLOLR5e
  const walletContract = client.open(wallet);
  const seqno = await walletContract.getSeqno();
  await walletContract.sendTransfer({
    secretKey: key.secretKey,
    seqno: seqno,
    messages: [
      internal({
        to: "EQA4V9tF4lY2S_J-sEQR7aUj9IwW-Ou2vJQlCn--2DLOLR5e",
        value: "0.05", // 0.05 TON
        body: "Hello", // optional comment
        bounce: false,
      })
    ]
  });

  // wait until confirmed
  let currentSeqno = seqno;
  while (currentSeqno == seqno) {
    console.log("waiting for transaction to confirm...");
    await sleep(1500);
    currentSeqno = await walletContract.getSeqno();
  }
  console.log("transaction confirmed!");
}

main();

function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
Execute the script by running in terminal:

copied!
npx ts-node step9.ts
Once the wallet signs and sends a transaction, we must wait until TON Blockchain validators insert this transaction into a new block. Since block time on TON is approx 5 seconds, it will usually take 5-10 seconds until the transaction confirms. Try looking for this outgoing transaction in the Tonscan explorer. After running the code, you will see the NFT minted in your wallet soon.

If you're getting errors in this step, please triple check that the wallet contract you're using is deployed and funded. If you're using the wrong wallet version for example, you'll end up using a wallet contract that isn't deployed and the transaction will fail.

TON Hello World part 2: Step by step guide for writing your first smart contract

by Tal Kol
 
A smart contract is simply a computer program running on TON Blockchain - or more exactly its TVM (TON Virtual Machine). The contract is made of code (compiled TVM instructions) and data (persistent state) that are stored in some address on TON Blockchain.

In the world of blockchain, code is law, meaning that instead of lawyers and papers, computer instructions define in absolute terms the rules of interaction between the different users of the contract. Before engaging with any smart contract as a user, you're expected to review its code and thus understand its terms of agreement. Accordingly, we'll make an effort to make our contract as easy to read as possible, so its users could understand what they're getting into.

Dapps - decentralized applications
Smart contracts are a key part of decentralized apps - a special type of application invented in the blockchain era, that does not depend on any single entity to run it. Unlike the app Uber, for example, which depends on the company Uber Inc to run it - a decentralized Uber would allow riders and drivers to interact directly (order, pay for and fulfill rides) without any intermediary like Uber Inc. Dapps are also unstoppable - if we don't depend on anyone specific to run them, nobody can take them down.

Dapps on TON Blockchain are usually made of 2 main projects:

Smart contracts in the FunC programming language that are deployed on-chain - these act as the backend server of the app, with a database for persistent storage.

Web frontend for interacting with the dapp from a web browser - this acts as the frontend or client, normally with special support for Telegram messenger in the form of a Telegram Web App.

Throughout this series of tutorials, we will build a full dapp together and see detailed implementations of both projects.

Step 1: Define our first smart contract
So what are we going to build? Our smart contract will be quite simple:

Its main feature is to hold a counter. The counter will start at some number, and allow users to send increment transactions to the contract, which will in turn increase the counter value by 1. The contract will also have a getter function that will allow any user to query the current value of the counter.

In later tutorials we will make this contract a little more advanced and allow TON coins that are deposited in it to be withdrawn by a special admin role. This admin will also be able to transfer ownership to a different admin and more.

Step 2: Set up your local machine
Before we can start writing code, we need to install certain developer tools on our computer.

For convenience, our development environment will rely on several clever scripts for testing, compiling and deploying our code. The most convenient language for these scripts is JavaScript, executed by an engine called Node.js. The installation instructions are here. We will need a fairly recent version of node like v18. You can verify your nodejs version by running node -v in terminal.

You will also need a decent IDE with FunC and TypeScript support. I recommend Visual Studio Code - it's free and open source. Also install the FunC Plugin to add syntax highlighting for the FunC language.

Step 3: Set up the project
Let's open a terminal in the project directory where you want to place your project. When you run the following command, be sure to choose "Counter" as the contract name and select "an empty contract (FunC)" from the list of templates. This will help prevent any issues in the future.

copied!
npm create ton@latest
This will create a new project with a preconfigured structure, which includes a workflow for developing, testing, and deploying smart contracts using the Blueprint SDK. The project structure will initially consist of four directories: contracts, wrappers, tests, and scripts. Later on, we will also create a build directory.

And finally, execute the following command to open a folder, allowing us to proceed with the tutorial:

copied!
cd your_project_directory
Step 4: Structuring our smart contract
Much like everything else in life, smart contracts in FunC are divided into 3 sections. These sections are: storage, messages and getters.

The storage section deals with our contract's persistent data. Our contract will have to store data between calls from different users, for example the value of our counter variable. To write this data to state storage, we will need a write/encode function and to read this data back from state storage, we will need a read/decode function.

The messages section deals with messages sent to our contract. The main form of interaction with contracts on TON Blockchain is by sending them messages. We mentioned before that our contract will need to support a variety of actions like increment, deposit, withdraw and transfer ownership. All of these operations are performed by users as transactions. These operations are not read-only because they change something in the contract's persistent state.

The getters section deals with read-only interactions that don't change state. For example, we would want to allow users to query the value of our counter, so we can implement a getter for that. We've also mentioned that the contract has a special owner, so what about a getter to query that. Since our contract can hold money (TON coins), another useful getter could be to query the current balance.

Step 5: Implement the Counter contract
We're about to write our first lines in FunC! Our first task would be to implement the counter feature of our contract.

The FunC programming language is very similar to the C language. It has strict types, which is a good idea, since compilation errors will help us spot contract mistakes early on. The language was designed specifically for TON Blockchain, so you will not find a lot of documentation beyond the official FunC docs.

Before the first section, please remember to keep the following line of code at the beginning of the file to import the standard library, as its absence can cause issues later on.

copied!
#include "imports/stdlib.fc";
Storage
Let's start with the first section, storage, and implement two utility functions (which we will use later) for reading and writing variables to the contract's persistent state - load_data() and save_data(). The primary variable will be the counter value. We must persist this value to storage because we need to remember it between calls. The appropriate type for our counter variable is int. Notice in the docs that the int TVM runtime type is always 257 bit long (256 bit signed) so it can hold huge huge numbers - I'm pretty sure the universe has less than 2^256 atoms in it, so you'll never have a number so large that you can't fit in it. Storing the full 257 bits in blockchain storage is somewhat wasteful because the contract pays rent proportionally to the total amount of data it keeps. To optimize costs, let's keep in persistent storage just the lowest 64 bits - capping our counter's maximum value at 2^64 which should be enough:

copied!
(int) load_data() inline {                 ;; read function declaration - returns int as result
  var ds = get_data().begin_parse();       ;; load the storage cell and start parsing as a slice
  return (ds~load_uint(64));               ;; read a 64 bit unsigned int from the slice and return it
}

() save_data(int counter) impure inline {  ;; write function declaration - takes an int as arg
  set_data(begin_cell()                    ;; store the storage cell and create it with a builder
    .store_uint(counter, 64)               ;; write a 64 bit unsigned int to the builder
    .end_cell());                          ;; convert the builder to a cell
}
The standard library functions get_data() and set_data() are documented here and load/store the storage cell. We will cover cells in detail in future posts of this series. Cells are read from using the slice type (an array of bits) and written to using the builder type. The various methods that you see are all taken from the standard library. Also notice two interesting function modifiers that appear in the declarations - inline and impure.

Messages
Let's continue to the next section, messages, and implement the main message handler of our contract - recv_internal(). This is the primary entry point of our contract. It runs whenever a message is sent as a transaction to the contract by another contract or by a user's wallet contract:

copied!
() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {  ;; well known function signature
  if (in_msg_body.slice_empty?()) {         ;; check if incoming message is empty (with no body)
    return ();                              ;; return successfully and accept an empty message
  }
  int op = in_msg_body~load_uint(32);       ;; parse the operation type encoded in the beginning of msg body
  var (counter) = load_data();              ;; call our read utility function to load values from storage
  if (op == 1) {                            ;; handle op #1 = increment
    save_data(counter + 1);                 ;; call our write utility function to persist values to storage
  }
}
Messages sent between contracts are called internal messages. TON also supports external messages through the handler recv_external(), but as a dapp developer you're never expected to use them. External messages are used for very specific cases, mainly when implementing wallet contracts, that you would normally never have to write by yourself. You can safely ignore them.

Internal messages received by the contract may be empty. This is what happens for example when somebody sends TON coins to the contract from their wallet. This is useful for funding the contract so it can pay fees. In order to be able to receive those incoming transfers we will have to return successfully when an empty message arrives.

If an incoming message is not empty, the first thing to do is read its operation type. By convention, internal messages are encoded with a 32 bit unsigned int in the beginning that acts as operation type (op for short). We are free to assign any serial numbers we want to our different ops. In this case, we've assigned the number 1 to the increment action, which is handled by writing back to persistent state the current value counter plus 1.

Getters
Our last section, as you recall, is getters. Let's implement a simple getter that will allow users to query the counter value:

copied!
int counter() method_id {        ;; getter declaration - returns int as result
  var (counter) = load_data();   ;; call our read utility function to load value
  return counter;
}
We can choose what input arguments the getter takes as input and what output it returns as result. Also notice the function modifier appearing in the declaration - method_id. It is customary to place method_id on all getters.

That's it. We completed our 3 sections and the first version of our contract is ready. To get the complete code, simply concat the 3 snippets above and replace the existing code in contracts/counter.fc. This will be the FunC (.fc file extension) source file of our contract. The resulting source file should look like this.

Step 6: Build the counter contract
Right now, the contract is just FunC source code. To get it to run on-chain, we need to convert it to TVM bytecode.

In TON, we don't compile FunC directly to bytecode, but instead go through another programming language called Fift. Just like FunC, Fift is another language that was designed specifically for TON Blockchain. It's a low level language that is very close to TVM opcodes. For us regular mortals, Fift is not very useful, so unless you're planning on some extra advanced things, I believe you can safely ignore it for now.

Since we're using func-js for building, it would be a good idea to create a directory where we can store the build result. To do this, open the terminal and run the following command:

copied!
mkdir build
The func-js package contains everything we need to compile our contract to bytecode. To use it, open terminal in the project directory and run the following:

copied!
npx func-js contracts/counter.fc --boc build/counter.cell
The build should succeed, with the output of this command being a new file - counter.cell. This is a binary file that finally contains the TVM bytecode in cell format that is ready to be deployed on-chain. This will actually be the only file we need for deployment moving forward (we won't need the FunC source file).

Step 7: Prepare init data for deploying on-chain
Now that our contract has been compiled to bytecode, we can finally see it in action running on-chain. The act of uploading the bytecode to the blockchain is called deployment. The deployment result would be an address where the contract resides. This address will allow us to communicate with this specific contract instance later on and send it transactions.

There are two variations of TON Blockchain we can deploy to - mainnet and testnet. We covered both in the previous tutorial. Personally, I almost never deploy to testnet. There are far better ways to gain confidence that my code is working as expected. The primary of which is writing a dedicated test suite. We will cover this in detail in one of the next tutorials. For now, let's assume the code is working perfectly and no further debugging is required.

Init arguments
The new address of our deployed contract in TON depends on only two things - the deployed bytecode (initial code) and the initial contract storage (initial data). You can say that the address is some derivation of the hash of both. If two different developers were to deploy the exact same code with the exact same initialization data, they would collide.

The bytecode part is easy, we have that ready as a cell in the file counter.cell that we compiled in step 6. Now what about the initial contract storage? As you recall, the format of our persistent storage data was decided when we implemented the function save_data() of our contract FunC source. Our storage layout was very simple - just one unsigned int of 64 bit holding the counter value. Therefore, to initialize our contract, we would need to generate a data cell holding some arbitrary initial uint64 value - for example the number 1.

Interface class
The recommended way to interact with contracts is to create a small TypeScript class that will implement the interaction interface with the contract. We're using the project structure created by Blueprint, but we're still working on low-level aspects. Use the following code in wrappers/Counter.ts to create the initial data cell for deployment:

copied!
import { Contract, ContractProvider, Sender, Address, Cell, contractAddress, beginCell } from "@ton/core";

export default class Counter implements Contract {

  static createForDeploy(code: Cell, initialCounterValue: number): Counter {
    const data = beginCell()
      .storeUint(initialCounterValue, 64)
      .endCell();
    const workchain = 0; // deploy to workchain 0
    const address = contractAddress(workchain, { code, data });
    return new Counter(address, { code, data });
  }

  constructor(readonly address: Address, readonly init?: { code: Cell, data: Cell }) {}
}
Notice a few interesting things about this TypeScript code. First, it depends on the package @ton/core instead of @ton/ton, which contains a small subset of base types and is therefore slower to change - an important feature when building a stable interface for our contract. Second, the code that creates the data cell mimics the FunC API and is almost identical to our save_data() FunC function. Third, we can see the derivation of the contract address from the code cell and data cell using the function contractAddress.

The actual deployment involves sending the first message that will cause our contract to be deployed. We can piggyback any message that is directed towards our contract. This can even be the increment message with op #1, but we will do something simpler. We will just send some TON coins to our contract (an empty message) and piggyback that. Let's make this part of our interface. Add the function sendDeploy() to wrappers/Counter.ts - this function will send the deployment message:

copied!
// export default class Counter implements Contract {

  async sendDeploy(provider: ContractProvider, via: Sender) {
    await provider.internal(via, {
      value: "0.01", // send 0.01 TON to contract for rent
      bounce: false
    });
  }

// }
In every deployment we need to send some TON coins to our contract so that its balance is not zero. Contracts need to continually pay rent fees otherwise they risk being deleted. According to the docs, storage fees are about 4 TON per MB per year. Since our contract stores less than 1 KB, a balance of 0.01 TON should be enough for more than 2 years. In any case you can always check this in an explorer and send more TON to the contract if it runs low.

The resulting source file should look like this.

Step 8: Deploy the contract on-chain
Communicating with the live network for the deployment will require an RPC service provider - similar to Infura on Ethereum. These providers run TON Blockchain nodes and allow us to communicate with them over HTTP. TON Access is an awesome service that will provide us with unthrottled API access for free. It's also decentralized, which is the preferred way to access the network.

Install it by opening terminal in the project directory and running:

copied!
npm install @orbs-network/ton-access
The deployment is going to cost gas and should be done through a wallet that will fund it. I'm assuming that you have some familiarity with TON wallets and how they're derived from 24 word secret mnemonics. If not, be sure to follow the previous tutorial in this series.

As you recall from the previous tutorial, TON wallets can come in multiple versions. The code below relies on "wallet v4 r2", if your wallet is different, either switch Tonkeeper through "Settings" to this version, or modify the code below to use your version. Also remember to use a wallet works with the correct network you've chosen - testnet or mainnet.

Replace the current code in scripts/deployCounter.ts with a script that will use the interface class we have just written:

copied!
import * as fs from "fs";
import { getHttpEndpoint } from "@orbs-network/ton-access";
import { mnemonicToWalletKey } from "@ton/crypto";
import { TonClient, Cell, WalletContractV4 } from "@ton/ton";
import Counter from "../wrappers/Counter"; // this is the interface class from step 7

export async function run() {
  // initialize ton rpc client on testnet
  const endpoint = await getHttpEndpoint({ network: "testnet" });
  const client = new TonClient({ endpoint });

  // prepare Counter's initial code and data cells for deployment
  const counterCode = Cell.fromBoc(fs.readFileSync("build/counter.cell"))[0]; // compilation output from step 6
  const initialCounterValue = Date.now(); // to avoid collisions use current number of milliseconds since epoch as initial value
  const counter = Counter.createForDeploy(counterCode, initialCounterValue);

  // exit if contract is already deployed
  console.log("contract address:", counter.address.toString());
  if (await client.isContractDeployed(counter.address)) {
    return console.log("Counter already deployed");
  }

  // open wallet v4 (notice the correct wallet version here)
  const mnemonic = "unfold sugar water ..."; // your 24 secret words (replace ... with the rest of the words)
  const key = await mnemonicToWalletKey(mnemonic.split(" "));
  const wallet = WalletContractV4.create({ publicKey: key.publicKey, workchain: 0 });
  if (!await client.isContractDeployed(wallet.address)) {
    return console.log("wallet is not deployed");
  }

  // open wallet and read the current seqno of the wallet
  const walletContract = client.open(wallet);
  const walletSender = walletContract.sender(key.secretKey);
  const seqno = await walletContract.getSeqno();

  // send the deploy transaction
  const counterContract = client.open(counter);
  await counterContract.sendDeploy(walletSender);

  // wait until confirmed
  let currentSeqno = seqno;
  while (currentSeqno == seqno) {
    console.log("waiting for deploy transaction to confirm...");
    await sleep(1500);
    currentSeqno = await walletContract.getSeqno();
  }
  console.log("deploy transaction confirmed!");
}

function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
Before running this code, make sure you have enough TON in your wallet for the gas payments and the TON sent to the contract during the deploy.

Another thing to watch out for is collisions between different users of this tutorial. As you recall, if the code and initial data of two contracts are identical, they will have the same address. If all followers of this tutorial would choose initial counter value of 1 - then all of them would collide and only the first would actually deploy the contract. To make sure this doesn't happen, the code above initializes the counter value to the current number of milliseconds since the epoch (something like 1674253934361). This guarantees that your contract for deployment is unique.

To deploy a contract using our script, run the following command in the terminal and follow the on-screen instructions:

copied!
npx blueprint run
If you have network connectivity issues and get errors like backend nodes unhealthy or timeouts, please join the Telegram support chat for TON access to get assistance. A common mistake is trying to use a wallet contract that isn't deployed or funded. This can happen if you're setting the wrong wallet version. As explained in the previous tutorial, check your wallet address in an explorer and if your wallet has a different version from "wallet v4 r2" you will need to modify slightly the code above. Let's say for example that your version is "wallet v3 r2", then replace WalletContractV4 with WalletContractV3R2.

The script will print the newly deployed contract address - mine is EQBYLTm4nsvoqJRvs_L-IGNKwWs5RKe19HBK_lFadf19FUfb. You can open your address in an explorer to verify that the deploy went smoothly. This is what it should look like:



Write down your deployed contract address. We're going to use it in the next step.

Step 9: Call a getter on the deployed contract
There are two ways to interact with a smart contract - calling a getter to read data from it or sending a message that can potentially change its state (write). We should support these interactions in the contract interface class that we created in step 7.

Anyone who wants to access the contract from TypeScript would simply use this interface class. This is excellent for separation of responsibilities within your team. The developer of the contract can provide this class to the developer of the client to abstract away implementation details such as how messages should be encoded in the binary level. Let's start with the getter.

Interface class
Add the following to wrappers/Counter.ts:

copied!
// export default class Counter implements Contract {

  async getCounter(provider: ContractProvider) {
    const { stack } = await provider.get("counter", []);
    return stack.readBigNumber();
  }

// }
Notice that methods in the interface class that call getters must start with the word get. This prefix is a requirement of the @ton/ton TypeScript library. The resulting source file should look like this.

Executing the call
Calling a getter is free and does not cost gas. The reason is that this call is read-only, so it does not require consensus by the validators and is not stored in a block on-chain for all eternity like transaction are.

Let's create a new script called getCounter.ts in the scripts folder and use our shiny interface class to make the call. We're going to emulate a different developer interacting with our contract and since the contract is already deployed, they are likely to access it by address. Be sure to replace my deployed contract address with yours in the code below:

copied!
import { getHttpEndpoint } from "@orbs-network/ton-access";
import { TonClient, Address } from "@ton/ton";
import Counter from "../wrappers/Counter"; // this is the interface class we just implemented

export async function run() {
  // initialize ton rpc client on testnet
  const endpoint = await getHttpEndpoint({ network: "testnet" });
  const client = new TonClient({ endpoint });

  // open Counter instance by address
  const counterAddress = Address.parse("EQBYLTm4nsvoqJRvs_L-IGNKwWs5RKe19HBK_lFadf19FUfb"); // replace with your address from step 8
  const counter = new Counter(counterAddress);
  const counterContract = client.open(counter);

  // call the getter on chain
  const counterValue = await counterContract.getCounter();
  console.log("value:", counterValue.toString());
}
As always, run the script using the terminal and follow the instructions displayed on the screen. Make sure to choose "getCounter" from the list of available scripts.

copied!
npx blueprint run
Make a note of the current counter value. After we send the increment message in the next step we would like to confirm that this value indeed increases by 1.

Another interesting thing to remember is that getters are only accessible off-chain, for example from a JavaScript client making a call through an RPC service provider. In particular, this means that contracts cannot call getters on other contracts.

Step 10: Send a transaction to the deployed contract
Unlike getters that are read-only, messages can write and change contract state in storage. In our contract implementation we handled messages in recv_internal() and assigned op #1 = increment. Sending messages costs gas and requires payment in TON coin. The reason is that this operation is not read-only, so it requires waiting for consensus by the validators and is stored as a transaction in a block on-chain for all eternity. We will send less TON coin this time since this action is much cheaper than the deployment.

Interface class
Add the following to wrappers/Counter.ts:

copied!
// export default class Counter implements Contract {

  async sendIncrement(provider: ContractProvider, via: Sender) {
    const messageBody = beginCell()
      .storeUint(1, 32) // op (op #1 = increment)
      .storeUint(0, 64) // query id
      .endCell();
    await provider.internal(via, {
      value: "0.002", // send 0.002 TON for gas
      body: messageBody
    });
  }

// }
As you recall, the increment message is an internal message that is encoded by convention with a 32 bit unsigned int in the beginning to describe the op and a 64 bit unsigned int after to describe the query id. The query id is relevant for messages that expect a response message to be sent back (the request and the response share the same query id).

Notice that methods in the interface class that send messages must start with the word send, another prefix requirement of the @ton/ton library. The resulting source file should look like this.

Executing the send
The messages can be sent from any TON wallet, not necessarily the deployer wallet. Create a new script sendIncrement.ts in the scripts folder and use your wallet to fund the send:

copied!
import { getHttpEndpoint } from "@orbs-network/ton-access";
import { mnemonicToWalletKey } from "@ton/crypto";
import { TonClient, WalletContractV4, Address } from "@ton/ton";
import Counter from "../wrappers/Counter"; // this is the interface class we just implemented

export async function run() {
  // initialize ton rpc client on testnet
  const endpoint = await getHttpEndpoint({ network: "testnet" });
  const client = new TonClient({ endpoint });

  // open wallet v4 (notice the correct wallet version here)
  const mnemonic = "unfold sugar water ..."; // your 24 secret words (replace ... with the rest of the words)
  const key = await mnemonicToWalletKey(mnemonic.split(" "));
  const wallet = WalletContractV4.create({ publicKey: key.publicKey, workchain: 0 });
  if (!await client.isContractDeployed(wallet.address)) {
    return console.log("wallet is not deployed");
  }

  // open wallet and read the current seqno of the wallet
  const walletContract = client.open(wallet);
  const walletSender = walletContract.sender(key.secretKey);
  const seqno = await walletContract.getSeqno();

  // open Counter instance by address
  const counterAddress = Address.parse("EQBYLTm4nsvoqJRvs_L-IGNKwWs5RKe19HBK_lFadf19FUfb"); // replace with your address from step 8
  const counter = new Counter(counterAddress);
  const counterContract = client.open(counter);

  // send the increment transaction
  await counterContract.sendIncrement(walletSender);

  // wait until confirmed
  let currentSeqno = seqno;
  while (currentSeqno == seqno) {
    console.log("waiting for transaction to confirm...");
    await sleep(1500);
    currentSeqno = await walletContract.getSeqno();
  }
  console.log("transaction confirmed!");
}

function sleep(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}
As always, run the script using the terminal and follow the instructions displayed on the screen. Make sure to choose "sendIncrement" from the list of available scripts.

copied!
npx blueprint run
Notice that the message will take a few seconds to be processed by validators and will only change contract state after it has been processed. The normal wait time is a block or two, since validators need to produce a new block that contains our sent transaction. The op that was sent above is #1 = increment, which means that after processing, the counter value will increase by 1. Verify this by re-running the script from step 9 to print the new counter value.

Messages can be sent to our contract by other contracts. This means a different contract can increment our counter. This allows the TON ecosystem to create composable apps and protocols that build on top of each other and interact in unforeseen ways.

Reward
Congratulations on successfully completing this tutorial! Before we conclude, let's take a quick look at the exciting reward awaiting you from the "TON Masters" collection:

Ready to claim your reward? Simply scan the QR code below or click here:QR-code

Conclusion
For your convenience, all the code in this tutorial is available in executable form here.

In this tutorial we handled the build and deploy processes manually, mostly so we can understand what happens under the hood. When creating a new contract project, you can have these processes managed automatically by an awesome dev tool called Blueprint. To create a new contract project with Blueprint, run in terminal and follow the on-screen instructions:

copied!
npm create ton@latest
If you found a mistake in this tutorial, please submit a PR and help us fix it. This tutorial platform is fully open source and available on https://github.com/ton-community/tutorials.

TON Hello World part 3: Step by step guide for building your first web client

by Shahar Yakir
 
In the previous tutorial we deployed a Counter smart contract to TON Blockchain (either testnet or mainnet). This contract acts as the backend server of our application. In this tutorial, we will implement the frontend or client and allow end-users to access it from a web browser.

We will also recall that the appilcation that we're building is decentralized. Decentralized apps (dapps) have special properties. For example, their frontend must only run client-side. This means that we're not supposed to rely on a backend server for serving our frontend. If we had such a server, by definition it would be centralized (our end-users will not have equal access to it), and thus make our entire app centralized as well.

Step 1: Define usage patterns
TON Blockchain is inspired by and complementary to Telegram messenger. It aims for mass adoption by the next billion users. Since Telegram messenger is a mobile-first app, it makes sense that we design our dapp to be mobile-first as well.

The first usage pattern of our dapp would be through a regular web browser. Our frontend would be hosted on some domain using a service like GitHub Pages. End-users would input the dapp URL in their favorite web browser and access our dapp using HTML and JavaScript. This is quite standard.

The second usage pattern is a bit more special. Since TON Blockchain complements the Telegram messenger, we will also want to embed our dapp right into the Telegram app itself. Telegram provides special API for building Telegam Web Apps (TWAs). These tiny apps closely resemble websites and also rely on HTML and JavaScript. They normally run within the context of a Telegram bot and provide a sleek user experience without ever leaving the host Telegram app.



During the course of this tutorial we will create a single codebase that will accomodate both usage patterns.

Step 2: Set up your local machine
Before we can start writing code, we need to install certain developer tools on our computer.

Since our frontend will run inside a browser, it will be implemented in JavaScript. The most convenient runtime for developing JavaScript projects is Nodejs. The installation instructions are here. We will need a fairly recent version of node like v16 or v17. You can verify your nodejs version by running node -v in terminal.

The second tool we need is an initialized TON wallet like Tonkeeper. If you don't have a wallet, please take a look at tutorial 1. The wallet will communicate with our dapp via a protocol called TON Connect 2. If you choose a different wallet than Tonkeeper, please verify it supports this version of TON Connect. Don't forget to make sure your wallet is connected to the correct network - mainnet or testnet.

Step 3: Set up the project
We will build our frontend with React. To create our project we will rely on Vite and its React template. Choose a name for your project, for example my-twa, then open terminal and run the following:

copied!
npm create vite@latest my-twa -- --template react-ts
cd my-twa
npm install
We will need to install a few more packages that will allow us to interact with TON Blockchain. We've seen these packages in action in the previous tutorial. Run the following in terminal:

copied!
npm install @ton/ton @ton/core @ton/crypto
npm install @orbs-network/ton-access
Last but not least, we will need to overcome @ton/ton library's reliance on Nodejs Buffer that isn't available in the browser. We can do that by installing a polyfill. Run the following in terminal:

copied!
npm install vite-plugin-node-polyfills
Now modify the file vite.config.ts so it looks like this:

copied!
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { nodePolyfills } from 'vite-plugin-node-polyfills';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react(), nodePolyfills()],
  base: '/',
});
To see your empty app template, run in terminal:

copied!
npm run dev
Then open a web browser and direct it the URL shown on-screen (like http://localhost:5173/).

Step 4: Set up TON Connect
TON Connect is the protocol by which our app will communicate with the end-user's wallet. The TON Connect React library will provide us with some useful services like showing the end-user a list of TON Connect 2 supported wallets, querying the user's wallet for its public address and sending a transaction through the wallet.

Install the library by running in terminal:

copied!
npm install @tonconnect/ui-react
When our app connects to the user's wallet, it will identify itself using a manifest file. The wallet will ask for the user's permission to connect to the app and display the information from the manifest. Since the manifest needs to be publicly available on the Internet, we're going to use an example one that I've deployed in advance during development. Later, when we deploy our website, we will replace the example manifest with your real one.

Modify the file src/main.tsx to use the TON Connect provider:

copied!
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
import { TonConnectUIProvider } from '@tonconnect/ui-react';

// this manifest is used temporarily for development purposes
const manifestUrl = 'https://raw.githubusercontent.com/ton-community/tutorials/main/03-client/test/public/tonconnect-manifest.json';

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <TonConnectUIProvider manifestUrl={manifestUrl}>
    <App />
  </TonConnectUIProvider>,
)
Step 5: Add a Connect button to the app
The first action we're going to offer the user is to Connect their wallet to the app. By connecting, the user agrees to share their public wallet address with the app. This isn't very dangerous since the entire transaction history of the wallet and its balance are publicly available on-chain anyways.

Edit the file src/App.tsx and replace its contents with the following:

copied!
import './App.css';
import { TonConnectButton } from '@tonconnect/ui-react';

function App() {
  return (
    <div>
      <TonConnectButton />
    </div>
  );
}

export default App
The only thing our new app UI will have is the Connect button. To run the app, run in terminal:

copied!
npm run dev
Then refresh the web browser viewing the URL shown on-screen. I'm assuming you're using the web browser on your desktop (where you're developing) and your Tonkeeper wallet is installed on your mobile device. Click "Connect Wallet" on the desktop and choose "Tonkeeper" (or any other supporting wallet you're using).

TON Connect supports both mobile-mobile user flows and desktop-mobile user flows. Since development is a desktop-mobile flow, TON Connect will rely on scanning QR codes in order to communicate with the wallet running on your mobile device. Open the Tonkeeper mobile app, tap the QR button on the top right and scan the code from your desktop screen.

If everything is wired properly, you should see a confirmation dialong in the wallet mobile app. If you approve the connection, you will see your address in the web app UI!

Step 6: Read the counter value from the chain
It's time to interact with our Counter contract and show the current counter value. To do that, we will need the TypeScript interface class that we created in tutorial 2. This class is useful because it defines all possible interactions with the contract in a manner that abstracts implementation and encoding details. This is particularly useful when you have one developer in your team that writes the contract and a different developer that builds the frontend.

Copy counter.ts from tutorial 2 to src/contracts/counter.ts (also available here).

The next thing we'll do is implement a general purpose React hook that will assist us in initializing async objects. Create the file src/hooks/useAsyncInitialize.ts with the following content:

copied!
import { useEffect, useState } from 'react';

export function useAsyncInitialize<T>(func: () => Promise<T>, deps: any[] = []) {
  const [state, setState] = useState<T | undefined>();
  useEffect(() => {
    (async () => {
      setState(await func());
    })();
  }, deps);

  return state;
}
Next, we're going to create another React hook that will rely on useAsyncInitialize and will initialize an RPC client in our app. An RPC service provider similar to Infura on Ethereum will allow us to query data from the chain. These providers run TON Blockchain nodes and allow us to communicate with them over HTTP. TON Access is an awesome service that will provide us with unthrottled API access for free. It's also decentralized, which is the preferred way to access the network.

Create the file src/hooks/useTonClient.ts with the following content:

copied!
import { getHttpEndpoint } from '@orbs-network/ton-access';
import { TonClient } from "@ton/ton";
import { useAsyncInitialize } from './useAsyncInitialize';

export function useTonClient() {
  return useAsyncInitialize(
    async () =>
      new TonClient({
        endpoint: await getHttpEndpoint({ network: 'testnet' }),
      })
  );
}
Our final hook will open the Counter contract instance on-chain by address and allow the app to access it. When our frontend developer starts working on the client, the contract should already be deployed. This means all they need to access it is the deployment address. We've done the deployment in tutorial 2 step 8. The address we got was EQBYLTm4nsvoqJRvs_L-IGNKwWs5RKe19HBK_lFadf19FUfb but yours should be different.

Create the file src/hooks/useCounterContract.ts with the following content. Be sure to replace our deployed contract address with yours in the code below:

copied!
import { useEffect, useState } from 'react';
import Counter from '../contracts/counter';
import { useTonClient } from './useTonClient';
import { useAsyncInitialize } from './useAsyncInitialize';
import { Address, OpenedContract } from '@ton/core';

export function useCounterContract() {
  const client = useTonClient();
  const [val, setVal] = useState<null | number>();

  const counterContract = useAsyncInitialize(async () => {
    if (!client) return;
    const contract = new Counter(
      Address.parse('EQBYLTm4nsvoqJRvs_L-IGNKwWs5RKe19HBK_lFadf19FUfb') // replace with your address from tutorial 2 step 8
    );
    return client.open(contract) as OpenedContract<Counter>;
  }, [client]);

  useEffect(() => {
    async function getValue() {
      if (!counterContract) return;
      setVal(null);
      const val = await counterContract.getCounter();
      setVal(Number(val));
    }
    getValue();
  }, [counterContract]);

  return {
    value: val,
    address: counterContract?.address.toString(),
  };
}
We're almost done. Let's add some simple UI to show this information on the main app screen. Replace src/App.tsx with the following content:

copied!
import './App.css';
import { TonConnectButton } from '@tonconnect/ui-react';
import { useCounterContract } from './hooks/useCounterContract';

function App() {
  const { value, address } = useCounterContract();

  return (
    <div className='App'>
      <div className='Container'>
        <TonConnectButton />

        <div className='Card'>
          <b>Counter Address</b>
          <div className='Hint'>{address?.slice(0, 30) + '...'}</div>
        </div>

        <div className='Card'>
          <b>Counter Value</b>
          <div>{value ?? 'Loading...'}</div>
        </div>
      </div>
    </div>
  );
}

export default App
To rebuild the web app, run in terminal:

copied!
npm run dev
Then refresh the web browser viewing the URL shown on-screen. You should see both the counter address and the counter value taken from the chain on the main screen. As you recall, we initialized the counter value to a very large value (number of milliseconds since the epoch, something like 1674271323207). Don't worry about styling, we will handle this later.

If you have network connectivity issues and get errors like backend nodes unhealthy or timeouts, please join the Telegram support chat for TON access to get assistance.

Step 7: Increment the counter on-chain
The last interaction was read-only, let's change the contract state by sending a transaction. The main action our counter contract supports is increment. Let's add a button to the main screen that sends this transaction. As you recall, sending a transaction on-chain costs gas, so we would expect the wallet to approve this action with the user and show how much TON coin will be spent.

Before starting, we're going to add another hook that will generate a sender object from the TON Connect interface. This sender represents the connected wallet and will allow us to send transactions on their behalf. While we're at it, we'll also expose the wallet connection state so we can alter the UI accordingly.

Create the file src/hooks/useTonConnect.ts with the following content:

copied!
import { useTonConnectUI } from '@tonconnect/ui-react';
import { Sender, SenderArguments } from '@ton/core';

export function useTonConnect(): { sender: Sender; connected: boolean } {
  const [tonConnectUI] = useTonConnectUI();

  return {
    sender: {
      send: async (args: SenderArguments) => {
        tonConnectUI.sendTransaction({
          messages: [
            {
              address: args.to.toString(),
              amount: args.value.toString(),
              payload: args.body?.toBoc().toString('base64'),
            },
          ],
          validUntil: Date.now() + 5 * 60 * 1000, // 5 minutes for user to approve
        });
      },
    },
    connected: tonConnectUI.connected,
  };
}
The next thing we're going to do is improve our existing useCounterContract hook and add two small features. The first is automatic polling of the counter value every 5 seconds. This will come in handy to show the user that the value indeed changed. The second is exposing the sendIncrement of our interface class and wiring it to the sender.

Open the file src/hooks/useCounterContract.ts and replace its contents with:

copied!
import { useEffect, useState } from 'react';
import Counter from '../contracts/counter';
import { useTonClient } from './useTonClient';
import { useAsyncInitialize } from './useAsyncInitialize';
import { useTonConnect } from './useTonConnect';
import { Address, OpenedContract } from '@ton/core';

export function useCounterContract() {
  const client = useTonClient();
  const [val, setVal] = useState<null | string>();
  const { sender } = useTonConnect();

  const sleep = (time: number) => new Promise((resolve) => setTimeout(resolve, time));

  const counterContract = useAsyncInitialize(async () => {
    if (!client) return;
    const contract = new Counter(
      Address.parse('EQBYLTm4nsvoqJRvs_L-IGNKwWs5RKe19HBK_lFadf19FUfb') // replace with your address from tutorial 2 step 8
    );
    return client.open(contract) as OpenedContract<Counter>;
  }, [client]);

  useEffect(() => {
    async function getValue() {
      if (!counterContract) return;
      setVal(null);
      const val = await counterContract.getCounter();
      setVal(val.toString());
      await sleep(5000); // sleep 5 seconds and poll value again
      getValue();
    }
    getValue();
  }, [counterContract]);

  return {
    value: val,
    address: counterContract?.address.toString(),
    sendIncrement: () => {
      return counterContract?.sendIncrement(sender);
    },
  };
}
We're almost done. Let's add simple UI to allow the user to trigger the increment. Replace src/App.tsx with the following content:

copied!
import './App.css';
import { TonConnectButton } from '@tonconnect/ui-react';
import { useTonConnect } from './hooks/useTonConnect';
import { useCounterContract } from './hooks/useCounterContract';

function App() {
  const { connected } = useTonConnect();
  const { value, address, sendIncrement } = useCounterContract();

  return (
    <div className='App'>
      <div className='Container'>
        <TonConnectButton />

        <div className='Card'>
          <b>Counter Address</b>
          <div className='Hint'>{address?.slice(0, 30) + '...'}</div>
        </div>

        <div className='Card'>
          <b>Counter Value</b>
          <div>{value ?? 'Loading...'}</div>
        </div>

        <a
          className={`Button ${connected ? 'Active' : 'Disabled'}`}
          onClick={() => {
            sendIncrement();
          }}
        >
          Increment
        </a>
      </div>
    </div>
  );
}

export default App
Time to rebuild the web app, run in terminal:

copied!
npm run dev
Then refresh the web browser viewing the URL shown on-screen. You should see a new "Increment" link on the bottom of the screen. I'm assuming that you're still on desktop, make a note of the counter value and click the link.

Since your mobile Tonkeeper wallet is connected, this action should reach the Tonkeeper mobile app and cause it to display a confirmation dialog. Notice that this dialog shows the gas cost of the transaction. Approve the transaction on the mobile app. Since the app and wallet are connected, your approval should reach the app and cause it to display an indication that the transaction was sent. As you recall, new transactions must wait until they're included in a block, so this should take 5-10 seconds.

If everything is working, the counter value on screen should refresh automatically and you should see a value that is higher by one.

Step 8: Style the app
Functionally our app is working, but we can definitely improve what it looks like. Giving a polished user experience is particularly important on TON Blockchain. We are aiming to reach mass adoption and the next billion users. We won't succeed unless our apps look as polished as the ones these users are already using.

Replace src/index.css with the following content:

copied!
:root {
  --tg-theme-bg-color: #efeff3;
  --tg-theme-button-color: #63d0f9;
  --tg-theme-button-text-color: black;
}

.App {
  height: 100vh;
  background-color: var(--tg-theme-bg-color);
  color: var(--tg-theme-text-color);
}

.Container {
  padding: 2rem;
  max-width: 500px;
  display: flex;
  flex-direction: column;
  gap: 30px;
  align-items: center;
  margin: 0 auto;
  text-align: center;
}

.Button {
  background-color: var(--tg-theme-button-color);
  color: var(--tg-theme-button-text-color);
  display: inline-block;
  padding: 10px 20px;
  border-radius: 10px;
  cursor: pointer;
  font-weight: bold;
  width: 100%;
}

.Disabled {
  filter: brightness(50%);
  cursor: initial;
}

.Button.Active:hover {
  filter: brightness(105%);
}

.Hint {
  color: var(--tg-theme-hint-color);
}

.Card {
  width: 100%;
  padding: 10px 20px;
  border-radius: 10px;
  background-color: white;
}

@media (prefers-color-scheme: dark) {
  :root {
    --tg-theme-bg-color: #131415;
    --tg-theme-text-color: #fff;
    --tg-theme-button-color: #32a6fb;
    --tg-theme-button-text-color: #fff;
  }

  .Card {
    background-color: var(--tg-theme-bg-color);
    filter: brightness(165%);
  }

  .CounterValue {
    border-radius: 16px;
    color: white;
    padding: 10px;
  }
}
As usual, to rebuild the web app, run in terminal:

copied!
npm run dev
And refresh the web browser viewing the URL shown on-screen. Our app should look pretty now.

Up until now we used our app in a desktop-mobile flow due to the development cycle. It would be nice to try our app in a mobile-mobile flow. This means we need to open the app's web page from a mobile device. This will be much easier to do after our web app is published to the Internet.

Step 9: Publish web app to GitHub Pages
I believe that the best place to publish dapps is GitHub Pages - not just for development but also for production. GitHub Pages is a free service for open source projects that allows them to publish static websites (HTML/CSS/JS) directly from a GitHub repo. Since all dapps should always be open source, all dapps qualify. GitHub Pages also supports custom domains, so the end result will be identical to any other production publishing service.

Another benefit of GitHub Pages is that it supports static websites only that only run client-side. There's no backend that can run code or server-side rendering. This limitation is actually a feature for dapps, because decentralized apps should never depend on backend servers as those are centralized.

The last important feature of GitHub Pages that makes it particularly appropriate for dapps is that the reliance on a git repo gives us many community governance features for free. For example, a group of maintainers can share the website deployment privilege easily because all of them have write access to the repo. Outside collaborators from the community can submit PRs and if those are merged, these community members can influence the live dapp. And lastly, if anyone from the community is unhappy with how the dapp is governed, they can always fork the GitHub repo and create their own independent client that can also be published to GitHub Pages in one click.

Let's assume that your GitHub username is my-gituser and that you pushed the client project to a GitHub repo named my-twa under this user. The GitHub URL of the repo is therefore https://github.com/my-gituser/my-twa. You will naturally have to replace the names in this example with the actual names that you're using.

Unless you connect a custom domain to GitHub Pages, the website will be published under the URL:

copied!
https://my-gituser.github.io/my-twa
Since we're about to go live, it's time to use a proper TON Connect manifest. This will allow us to style the initial connection dialog that appears in wallets like Tonkeeper.

Create the file public/tonconnect-manifest.json with this content:

copied!
{
  "url": "https://my-gituser.github.io/my-twa",
  "name": "My TWA",
  "iconUrl": "https://my-gituser.github.io/my-twa/icon.png"
}
Replace the URL field with your webite URL and choose a short name of your dapp. For icon, create a PNG file 180x180 pixels in size and put it under public/icon.png.

After we publish the website, this manifest file will be available at:

copied!
https://my-gituser.github.io/my-twa/tonconnect-manifest.json
Edit src/main.tsx and replace the constant manifestUrl with the future URL of your manifest:

copied!
const manifestUrl = 'https://my-gituser.github.io/my-twa/tonconnect-manifest.json';
Another step to remember is changing the base property of the Vite config file. If your future website is not going to be on the root of the domain (like you normally have with a custom domain), you must set base to the root directory of the website under the domain. In the example above, since the repo name is my-twa and the URL is https://my-gituser.github.io/my-twa, the website is published under the directory /my-twa/ in the domain.

Let's set this in vite.config.js:

copied!
export default defineConfig({
  plugins: [react(), nodePolyfills()],
  base: '/my-twa/',
});
Build the website for publishing by running in terminal:

copied!
npm run build
Publishing to GitHub Pages is pretty straightforward. You would normally create a git branch named gh-pages in your repo that contains the static website files that were generated in the dist directory during the build. Then you would normally open the repo on GitHub's web UI and enable "Pages" under "Settings" (pointing the "Branch" to "gh-pages" after it is pushed).

For the exact steps, you can follow Vite's tutorial for Deploying to GitHub Pages.

Once the website is published, we can finally access it from mobile. Take your mobile device and open the URL https://my-gituser.github.io/my-twa in the mobile browser.

This is a good opportunity to try the mobile-mobile flow. In the mobile browser, tap on the "Connect Wallet" button and choose "Tonkeeper" (or any other supporting wallet you're using). This should switch you to the Tonkeeper mobile app where you can approve the connection. After approval, you should be switched back to the website. Now tap the "Increment" button. This should switch you to the Tonkeeper mobile app where you can approve the transaction. As you can see, in the mobile-mobile flow there are no QR codes involved since the dapp and the wallet run on the same device.

Step 10: Publish web app as TWA in Telegram
Having our dapp accessible through a web browser is not enough. We want to make the most from the seamless integration into Telegram messenger. To feature our dapp in Telegram, we will also have to publish it as a TWA. Luckily, this is pretty easy to do.

The first step is to add the TWA SDK to our project. This will allow us to get theme properties while inside Telegram. Run in terminal:

copied!
npm install @twa-dev/sdk
Then, edit src/App.tsx and add the following import:

copied!
import '@twa-dev/sdk';
Now rebuild the website for publishing by running in terminal:

copied!
npm run build
Publish the updated website like we did in step 9, probably just by pushing it to git to the correct branch.

The final step is to create a new Telegram bot and have it showcase our website when opened. To do that we will interact with another Telegram bot called "botfather". On a device where your Telegram messenger is logged in, open https://t.me/botfather and then switch to the bot inside the Telegram app. Choose "Start".

To create a new bot select "/newbot". Choose a name for the bot and then a username according to the on-screen instructions. Make a note of the username since this is how end-users will access your TWA. Assuming that your bot username is my_twa_bot, it will be accessible in the Telegram chat by typing @my_twa_bot or through the URL https://t.me/my_twa_bot. You can even purchase a premium Telegram username for your bot on the auction platform Fragment.

Back in botfather, tap the menu button and edit your bots by selecting "/mybots". Select the bot you've just created. Select "Bot Settings" and then select "Menu Button". Now select "Configure menu button" to edit the URL and type your published website URL:

copied!
https://my-gituser.github.io/my-twa
That's it! The bot should be ready. Start a Telegram chat with your bot via the username. Tap the menu button and voila - your published website will open inside Telegram as a TWA. Congratulations!



Reward
Congratulations on successfully completing this tutorial! Before we conclude, let's take a quick look at the exciting reward awaiting you from the "TON Masters" collection:

Ready to claim your reward? Simply scan the QR code below or click here:QR-code

Conclusion
For your convenience, all the code in this tutorial is available in executable form here.

In this tutorial we created our project skeleton manually, mostly so we can understand what happens under the hood. When creating a new client project, you can start from a ready-made template that will save you most of the setup work:
https://github.com/ton-community/twa-template

If you found a mistake in this tutorial, please submit a PR and help us fix it. This tutorial platform is fully open source and available on https://github.com/ton-community/tutorials.

Happy coding!

TON Hello World part 4: Step by step guide for testing your first smart contract

by Tal Kol
 
Testing is a big part of smart contract development. Smart contracts often deal with money and we don't want any of our users losing money because the smart contract had a bug. This is why it's normally expected from smart contract developers to share an automated test suite next to their FunC implementation. Every user that wants to be convinced that the contract is working as expected is welcome to execute the test suite and see for themselves.

A thorough test suite is also a good signal to your users that you've taken your role as a contract developer seriously. I would personally be very hesitant to deposit a substantial amount of money in any contract that has no tests. Since code is law, any bug in the contract code is also part of the agreement, so a user wouldn't really have anyone to blame for money lost, but themselves.

Personally, I don't view testing as an afterthought taking place only when your code is complete. If done correctly, tests can be a powerful aid to the development process itself from the beginning, that will allow you to write better code faster.

Oh so many ways to test
Warning - this specific section is a bit more advanced than beginner, feel free to skip it directly to step 1 if you trust my judgement of how to test. If you're interested in an overly detailed overview of what other testing methodologies exist in our ecosystem please read on.

Because testing is such as big deal in smart contract development, there's a surprising amount of tools and infrastructure in the TON ecosystem devoted to this topic. Before jumping in to the methodology that I believe in, I want to give a quick overview of the plethora of testing tools that are available out there:

Deploying your contract to testnet - Testnet is a live alternative instance of the entire TON Blockchain where TON coin isn't the real deal and is free to get. This instance is obviously not as secure as mainnet, but offers an interesting staging environment where you can play.

Local blockchain with MyLocalTon - MyLocalTon is a Java-based desktop executable that runs a personal local instance of TON Blockchain on your machine that you can deploy contracts to and interact with. Another way to run a local private TON network is using Kubernetes with ton-k8s.

Writing tests in FunC - toncli is a command-line tool written in Python that runs on your machine and supports debug and unit tests for FunC contracts where the tests are also written in FunC (example).

Bare-bones TVM with Sandbox - Sandbox is a bare-bones version of just the TVM running on WebAssembly with a thin JavaScript wrapper that allows test interactions from TypeScript.

Deploying beta contracts to mainnet - This form of "testing in production" simply deploys alternative beta versions of your contracts to mainnet and uses real (not free) TON coin to play with them in a real environment. If you found a bug, you simply deploy new fixed beta versions and waste a little more money.

So which method should you choose? You definitely don't need all of them.

My team started building smart contracts on Ethereum in 2017, we've witnessed the evolution of the art of smart contract development almost from its infancy. While I'm well aware of fundamental differences between TON and the EVM, testing between the two platforms is not fundamentally different. All of the above approaches appeared on Ethereum at one point or another. And all of them practically disappeared - except two - the last two.

Testnets were once popular on Ethereum (funny names like Ropsten, Rinkeby and Goerli) but turned out to be a bad tradeoff between convenience and realism - they're slow and often more difficult to work with than mainnet (some wallets aren't compatible) and useless for integration tests with other contracts (eg. your contract interacts with somebody else's token) because nobody bothers to maintain up-to-date versions of their projects on testnet.

Local desktop versions of the entire blockchain, like Ganache UI, proved to be too slow for unit tests and ineffective for integration tests (for the same reason as testnets). They also don't play nicely with CI. People often confuse ganache-cli with a local blockchain, but it is actually a bare-bones EVM implemented in JavaScript.

Testing Solidity with Solidity proved to be too cumbersome as smart contract languages are inherently limited and restrictive by design and efficient testing seems to flourish on freeform languages like JavaScript. Trying to code a complex expectation in Solidity or simulate a difficult scenario is just too painful.

Bare-bones EVM turned out to be the holy grail. Most of the testing on Ethereum today takes place on Hardhat and Hardhat is a thin wrapper around EthereumJs which is an EVM implementation in JavaScript. This approach turned out to be the most convenient (ultra-fast CI-friendly unit tests) as well as realistic where it matters (live lazy-loaded forks of mainnets for integration tests).

Testing in production is useful for the last mile. Ethereum has less than 5 million active users yet over 40 million deployed contracts. The vast majority of all deployed contracts on Ethereum mainnet are beta versions that developers deployed for a few tests and then abandoned. Don't feel bad about polluting mainnet with garbage, nobody cares.

After carefully considering all available approaches, I hope I convinced you why we're going to spend 90% of our time testing with approach (4) and 10% of our time testing with approach (5). We're going to conveniently forget about the other approaches and avoid using them at all.

Step 1: Set up the project
Since we're using TypeScript for tests, make sure Nodejs is installed by running node -v in terminal and the version is at least v18. If you have an old version, you can upgrade with nvm.

Let's create a new directory for our project. Open terminal in the project directory and run the following:

copied!
npm install typescript jest @types/jest ts-jest
This will install TypeScript and the popular jest test runner. To configure TypeScript to run correctly, we need to create the file tsconfig.json and put it in the project root:

copied!
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}
And to configure jest to run correctly, we need to create the file jest.config.js and put it in the project root:

copied!
module.exports = {
  preset: "ts-jest",
  testEnvironment: "node",
};
And finally, run in terminal:

copied!
npm install @ton/core @ton/sandbox @ton/test-utils
This will install Sandbox and its dependencies. Sandbox is our magical library that will emulate TON Blockchain locally by running a bare-bones version of the TVM in process. This will guarantee that our tests will be blazingly fast and completely isolated.

Step 2: Load our contract in a test
Quick reminder, in tutorial 2, we compiled our Counter smart contract in step 6 and generated the file counter.cell which contains the TVM bytecode for our contract (code cell). In step 7, before deploying the contract, we initialized its persistent storage (data cell). Then, we created the TypeScript interface class counter.ts that combines the two to deploy our contract.

Dig into your completed tutorial 2 and copy both counter.cell (also available here) and counter.ts (also available here) to the project root.

We're going to deploy the Counter contract in our test using the interface class in an almost identical way to how we deployed it to the actual chain in tutorial 2:

copied!
// prepare Counter's initial code and data cells for deployment
const counterCode = Cell.fromBoc(fs.readFileSync("counter.cell"))[0]; // compilation output from tutorial 2
const initialCounterValue = 17; // no collisions possible since sandbox is a private local instance
const counter = Counter.createForDeploy(counterCode, initialCounterValue);
Notice that this time we can initialize the counter value to a simple number like 17 because we're no longer afraid of collisions. All users of this tutorial can end up with the same contract address and that's ok since Sandbox creates an isolated private blockchain.

Before we start writing tests, let's create our test skeleton. In the skeleton, before each test starts, we'll initialize a fresh instance of the entire blockchain. This instance will require a wallet with enough TON for all our gas needs (we call this a "treasury") and a deployed version of the Counter.

Create the file step2.spec.ts with the following content:

copied!
import * as fs from "fs";
import { Cell } from "@ton/core";
import { Blockchain, SandboxContract, TreasuryContract } from "@ton/sandbox";
import Counter from "./counter"; // this is the interface class from tutorial 2

describe("Counter tests", () => {
  let blockchain: Blockchain;
  let wallet1: SandboxContract<TreasuryContract>;
  let counterContract: SandboxContract<Counter>;

  beforeEach(async () =>  {
    // prepare Counter's initial code and data cells for deployment
    const counterCode = Cell.fromBoc(fs.readFileSync("counter.cell"))[0]; // compilation output from tutorial 2
    const initialCounterValue = 17; // no collisions possible since sandbox is a private local instance
    const counter = Counter.createForDeploy(counterCode, initialCounterValue);

    // initialize the blockchain sandbox
    blockchain = await Blockchain.create();
    wallet1 = await blockchain.treasury("user1");

    // deploy counter
    counterContract = blockchain.openContract(counter);
    await counterContract.sendDeploy(wallet1.getSender());
  }),

  it("should run the first test", async () => {
    // currently empty, will place a test body here soon
  });
});
This code is remarkably similar to the deploy code we had in tutorial 2. This is the benefit of using the TypeScript interface class. No matter where we use our contract, we always access it in the same familiar way.

The only strange part in this snippet is the treasury. What is it exactly? A treasury is simply a wallet contract, very similar to the v4 wallet you used with Tonkeeper in previous tutorials. What's useful with a treasury is that it's already pre initialized with a big TON coin balance. There's no need to fund it from a faucet.

To execute the test, run in terminal:

copied!
npx jest step2
Our test is empty, so it should naturally pass. Notice that if we had 3 different tests (3 different it() clauses), the blockchain would be initialized from scratch 3 times and the Counter would be deployed 3 times. This is excellent because different tests are completely isolated from each other. If one test fails, it will not influence the others.

Step 3: Test a getter
Now that the boilerplate is behind us, we can finally focus on writing the actual test logic. Ideally, we want to test through every execution path of our contract to make sure it's working. Let's start with something simple, our getter. Quick reminder, in tutorial 2 we implemented a getter in FunC that looked like this:

copied!
int counter() method_id {        ;; getter declaration - returns int as result
  var (counter) = load_data();   ;; call our read utility function to load value
  return counter;
}
As you recall, our test skeleton initializes our contract with a data cell via Counter.createForDeploy(). If the initial counter value is 17, we expect the getter to return 17 after initialization.

Copy the skeleton to a new file named step3.spec.ts and add the following test to it:

copied!
  it("should get counter value", async () => {
    const value = await counterContract.getCounter();
    expect(value).toEqual(17n);
  });
The resulting source file should look like this.

There's something interesting to notice in the assertion at the end of the test - the expect(). When we compare the counter value we don't compare it to the number 17, but to 17n. What is this notation? The n signifies that the number is a BigInt. The FunC type returned from our getter is int. This TVM number type is 257 bit long (256 signed) so it supports huge virtually unbounded numbers. The native JavaScript number type is limited to 64 bit so it cannot necessarily hold the result. We use JavaScript big numbers to work around this limitation.

To execute the test, run in terminal:

copied!
npx jest step3
The test should pass. Try to change the expectation to verify that the returning value is 18n and see how the test fails.

Step 4: Test a message
While getters are read-only operations that don't change contract state, messages are used to modify state through user transactions. Reminder, we've implemented the following message handler in tutorial 2:

copied!
() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {  ;; well known function signature
  if (in_msg_body.slice_empty?()) {         ;; check if incoming message is empty (with no body)
    return ();                              ;; return successfully and accept an empty message
  }
  int op = in_msg_body~load_uint(32);       ;; parse the operation type encoded in the beginning of msg body
  var (counter) = load_data();              ;; call our read utility function to load values from storage
  if (op == 1) {                            ;; handle op #1 = increment
    save_data(counter + 1);                 ;; call our write utility function to persist values to storage
  }
}
Let's write a test that sends a message with op #1 = increment. Our interface class already knows how to encode the message.

Copy the last test file to a new file named step4.spec.ts and add the following test to it:

copied!
  it("should increment the counter value", async () =>  {
    await counterContract.sendIncrement(wallet1.getSender());
    const counterValue = await counterContract.getCounter();
    expect(counterValue).toEqual(18n);
  })
The resulting source file should look like this.

Notice that we already know from the previous test that the counter is indeed initialized to 17, so if our message was successful, we can use the getter to get the counter value and make sure it has been incremented to 18.

To execute the test, run in terminal:

copied!
npx jest step4
Like before, the test should pass.

Step 5: Debug by dumping variables
Testing is fun as long as everything works as expected. But what happens when something doesn't work and you're not sure where the problem is? The most convenient method I found to debug your FunC code is to add debug prints in strategic places. This is very similar to debugging JavaScript by using console.log(variable) to print the value of variables.

The TVM has a special instruction for dumping variables in debug. Run ~dump(variable_name); in your FunC code to use it. You can also print constants by using ~dump(12345); which can be helpful to show that the VM indeed reached a certain line.

Another useful TVM instruction can dump strings in debug. Run ~strdump(string_value); in your FunC code to use it.

Let's try both. Let's say we're trying to send some TON coin to our contract on a message. We can do this by issuing a simple transfer from our wallet to our contract address. In FunC, this value should arrive under the msg_value argument of recv_internal(). Let's print this incoming value in FunC to make sure that it indeed works as expected. I added the debug print as the first line of our recv_internal() message handler from before:

copied!
() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {
  ~dump(msg_value);                         ;; first debug print
  if (in_msg_body.slice_empty?()) { 
    return (); 
  }
  int op = in_msg_body~load_uint(32);
  var (counter) = load_data();
  if (op == 1) {
    ~strdump("increment received");         ;; second debug print
    save_data(counter + 1);
  }
}
The second debug print I added is whenever an op #1 = increment message received. This time I print a constant string instead of a variable.

Since we changed our FunC code, we'll have to rebuild the contract to see the effect and generate a new counter.cell. I've done this for your convenience and renamed the file to counter.debug.cell, it is available here.

Copy the original test skeleton to a new file named step5.spec.ts and add the following tests:

copied!
  it("should send ton coin to the contract", async () => {
    console.log("sending 7.123 TON");
    await wallet1.send({
      to: counterContract.address,
      value: toNano("7.123")
    });
  });

  it("should increment the counter value", async () =>  {
    console.log("sending increment message");
    await counterContract.sendIncrement(wallet1.getSender());
  })
The resulting source file should look like this.

Run the test and take a close look at the console output in terminal:

copied!
npx jest step5
The console output should include something like this:

copied!
  console.log
    sending 7.123 TON

  console.log
    #DEBUG#: s0 = 7123000000

  console.log
    sending increment message

  console.log
    #DEBUG#: s0 = 2000000

  console.log
    #DEBUG#: increment received
We can see that the debug messages are printed when the test is running. When we send some TON coin explicitly to the contract (7.123 coins), we can see that the first debug print indeed shows the expected value of msg_value. Since the TVM doesn't support floating points, the number is represented internally as a large integer (with 9 decimals, meaning multiplied by 10^9). On the second test, when we send the increment op, we can see both debug prints showing. This is because this message also includes a small amount of coins for gas.

If you would like to see even more verbose log output from running your contracts, you can increase the verbosity of the blockchain object after creating it in beforeEach:

copied!
blockchain.verbosity = {
  print: true,
  blockchainLogs: true,
  vmLogs: "vm_logs_full",
  debugLogs: true,
}
Step 6: Test in production (without testnet)
Steps 2-5 above are all part of approach (4) - where I promised to spend 90% of our testing time. These tests are very fast to run (there's nothing faster than an in-process instance of a bare-bones TVM) and are very CI-friendly. They are also free and don't require you to spend any TON coin. These tests should give you the majority of confidence that your code is actually working.

What about the remaining 10%? All of our tests so far worked inside a lab. Before we're launching our contract, we should run some tests in the wild! This is what approach (5) is all about.

From a technical perspective, this is actually the simplest approach of all. You don't need to do anything special. Get some TON coin and deploy your contract to mainnet! The process was covered in detail in tutorial 2. Then, interact with your contract manually just like your users will. This will normally depend on the dapp client we wrote in tutorial 3.

If this step is so easy, why am I devoting so much time to discuss it? Because, from my experience, most dapp developers are reluctant to do so. Instead of testing on mainnet, they prefer to work on testnet. In my eyes, this is a waste of time. Let me attempt to refute any reasons to use testnet one last time:

"testnet is as easy to work with as mainnet" - False. Testnet is less reliable and isn't held to the same production standard as mainnet. It also requires special wallets and special explorers. This mess is going to cost you time to sort out. I've seen too many developers deploying their contract to testnet and then trying to inspect it with a mainnet explorer without understanding why they don't see anything deployed.

"mainnet is more expensive since it costs real TON coin to use" - False. Deploying your contract to mainnet costs around 10 cents. Your time costs more. Let's say an hour of your time is only worth the minimum wage in the US (a little over $7), if working on mainnet saves you an hour, you can deploy your contract 70 times without feeling guilty that you're wasting money.

"testnet is a good simulation of mainnet" - False. Nobody cares deeply about testnet since it's not a production network. Are you certain that validators on testnet are running the latest node versions? Are all config parameters like gas costs identical to mainnet? Are all contracts by other teams that you may be relying on deployed to testnet?

"I don't want to pollute mainnet with abandoned test contracts" - Don't worry about it. Users won't care since the chance of them reaching your unadvertised contract address by accident is zero. Validators won't care since you paid them for this service, they enjoy the traction. Also, TON has an auto-cleanup mechanism baked in, your contract will eventually run out of gas for rent and will be destroyed automatically.

Reward
Congratulations on successfully completing this tutorial! Before we conclude, let's take a quick look at the exciting reward awaiting you from the "TON Masters" collection:

Ready to claim your reward? Simply scan the QR code below or click here:QR-code

Conclusion
For your convenience, all the code in this tutorial is available in executable form here.

In this tutorial we created our project skeleton manually, mostly so we can understand what happens under the hood. When creating a new contract project, you can have an excellent skeleton created automatically by an awesome dev tool called Blueprint. To create a new contract project with Blueprint, run in terminal and follow the on-screen instructions:

copied!
npm create ton@latest
If you found a mistake in this tutorial, please submit a PR and help us fix it. This tutorial platform is fully open source and available on https://github.com/ton-community/tutorials.

Happy coding!

Get methods
note
To fully benefit from this content, readers must understand the FunC programming language on the TON Blockchain. This knowledge is crucial for grasping the information presented here.

Introduction
Get methods are special functions in smart contracts that allow you to query specific data. Their execution doesn't cost any fees and happens outside of the blockchain.

These functions are widespread in most smart contracts. For example, the default Wallet contract has several get methods, such as seqno(), get_subwallet_id() and get_public_key(). Wallets, SDKs, and APIs use them to fetch data about wallets.

Design patterns for get methods
Basic get methods design patterns
Single data point retrieval: A fundamental design pattern is to create methods that return individual data points from the contract's state. These methods have no parameters and return a single value.
Example:

int get_balance() method_id {
return get_data().begin_parse().preload_uint(64);
}

Aggregate data retrieval: Another common method is to create methods that gather multiple pieces of data from a contract's state in one call. This is useful when specific data points are often used together. You can see this approach frequently in Jetton and NFT contracts.
Example:

(int, slice, slice, cell) get_wallet_data() method_id {
return load_data();
}

Advanced get methods design patterns
Computed data retrieval: In some cases, the data that needs to be retrieved isn't stored directly in the contract's state but calculated based on the state and the input arguments.
Example:

slice get_wallet_address(slice owner_address) method_id {
(int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();
return calculate_user_jetton_wallet_address(owner_address, my_address(), jetton_wallet_code);
}


Conditional data retrieval: Sometimes, the data that needs to be retrieved depends on certain conditions, such as the current time.
Example:

(int) get_ready_to_be_used() method_id {
int ready? = now() >= 1686459600;
return ready?;
}

Most common get methods
Standard wallets
seqno()
int seqno() method_id {
 return get_data().begin_parse().preload_uint(32);
}

Returns the transaction's sequence number within a specific wallet. This method is primarily used for replay protection.

get_subwallet_id()
int get_subwallet_id() method_id {
 return get_data().begin_parse().skip_bits(32).preload_uint(32);
}

What is subwallet ID?
get_public_key()
int get_public_key() method_id {
 var cs = get_data().begin_parse().skip_bits(64);
 return cs.preload_uint(256);
}

This method retrieves the public key associated with the wallet.

Jettons
get_wallet_data()
(int, slice, slice, cell) get_wallet_data() method_id {
 return load_data();
}

This method returns the complete set of data associated with a jetton wallet:

(int) balance
(slice) owner_address
(slice) jetton_master_address
(cell) jetton_wallet_code
get_jetton_data()
(int, int, slice, cell, cell) get_jetton_data() method_id {
 (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();
 return (total_supply, -1, admin_address, content, jetton_wallet_code);
}


Returns data of a jetton master, including its total supply, the address of its admin, the content of the jetton, and its wallet code.

get_wallet_address(slice owner_address)
slice get_wallet_address(slice owner_address) method_id {
 (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();
 return calculate_user_jetton_wallet_address(owner_address, my_address(), jetton_wallet_code);
}


Given the owner's address, this method calculates and returns the address for the owner's jetton wallet contract.

NFTs
get_nft_data()
(int, int, slice, slice, cell) get_nft_data() method_id {
 (int init?, int index, slice collection_address, slice owner_address, cell content) = load_data();
 return (init?, index, collection_address, owner_address, content);
}


Returns the data associated with a non-fungible token, including whether it has been initialized, its index in a collection, the address of its collection, the owner's address, and its content.

get_collection_data()
(int, cell, slice) get_collection_data() method_id {
 var (owner_address, next_item_index, content, _, _) = load_data();
 slice cs = content.begin_parse();
 return (next_item_index, cs~load_ref(), owner_address);
}

Returns the data of an NFT collection, including the index of the next item available for minting, the content of the collection, and the owner's address.

get_nft_address_by_index(int index)
slice get_nft_address_by_index(int index) method_id {
 var (_, _, _, nft_item_code, _) = load_data();
 cell state_init = calculate_nft_item_state_init(index, nft_item_code);
 return calculate_nft_item_address(workchain(), state_init);
}

Given an index, this method calculates and returns the corresponding NFT item contract address within this collection.

royalty_params()
(int, int, slice) royalty_params() method_id {
 var (_, _, _, _, royalty) = load_data();
 slice rs = royalty.begin_parse();
 return (rs~load_uint(16), rs~load_uint(16), rs~load_msg_addr());
}

This method fetches the royalty parameters for an NFT. These parameters include the royalty percentage paid to the original creator whenever the NFT is sold.

get_nft_content(int index, cell individual_nft_content)
cell get_nft_content(int index, cell individual_nft_content) method_id {
 var (_, _, content, _, _) = load_data();
 slice cs = content.begin_parse();
 cs~load_ref();
 slice common_content = cs~load_ref().begin_parse();
 return (begin_cell()
 .store_uint(1, 8) ;; offchain tag
 .store_slice(common_content)
 .store_ref(individual_nft_content)
 .end_cell());
}

Given an index and individual NFT content, this method fetches and returns the NFT's combined common and individual content.

How to work with get methods
Calling get methods on popular explorers
Tonviewer
You can call get methods at the bottom of the page in the Methods tab.

https://tonviewer.com/EQAWrNGl875lXA6Fff7nIOwTIYuwiJMq0SmtJ5Txhgnz4tXI?section=method
Ton.cx
You can call get methods on the "Get methods" tab.

https://ton.cx/address/EQAWrNGl875lXA6Fff7nIOwTIYuwiJMq0SmtJ5Txhgnz4tXI
Calling get methods from code
We will use Javascript libraries and tools for the examples below:

ton library
Blueprint
Let's say there is some contract with the following get method:

(int) get_total() method_id {
 return get_data().begin_parse().preload_uint(32); ;; load and return the 32-bit number from the data
}


This method returns a single number loaded from the contract data.

You can use the code snippet below to call this get method on a contract deployed at a known address:

import { TonClient } from "@ton/ton";
import { Address } from "@ton/core";

async function main() {
  // Create Client
  const client = new TonClient({
    endpoint: "https://toncenter.com/api/v2/jsonRPC",
  });

  // Call get method
  const result = await client.runMethod(
    Address.parse("EQD4eA1SdQOivBbTczzElFmfiKu4SXNL4S29TReQwzzr_70k"),
    "get_total"
  );
  const total = result.stack.readNumber();
  console.log("Total:", total);
}

main();

This code will produce an output in the format Total: 123. The number may vary, as this is just an example.

Testing get methods
We can use the Sandbox to test smart contracts, which is installed by default in new Blueprint projects.

First, you must add a special method in the contract wrapper to execute the get method and return the typed result. Let's say your contract is called Counter, and you have already implemented the method to update the stored number. Open wrappers/Counter.ts and add the following method:

async getTotal(provider: ContractProvider) {
    const result = (await provider.get('get_total', [])).stack;
    return result.readNumber();
}

It executes the get method and retrieves the resulting stack. In this snippet, we read a single number from the stack. In more complex cases where multiple values are returned at once, you can simply call the readSomething type of method multiple times to parse the entire execution result from the stack.

Finally, we can use this method in our tests. Navigate to the tests/Counter.spec.ts and add a new test:

it("should return correct number from get method", async () => {
  const caller = await blockchain.treasury("caller");
  await counter.sendNumber(caller.getSender(), toNano("0.01"), 123);
  expect(await counter.getTotal()).toEqual(123);
});

You can check it by running npx blueprint test in your terminal. If you did everything correctly, this test should be marked as passed!

Invoking get methods from other contracts
Contrary to what might seem intuitive, invoking get methods from other contracts is impossible on-chain. This limitation stems primarily from the nature of blockchain technology and the need for consensus.

First, acquiring data from another ShardChain may introduce significant latency. Such delays could disrupt the contract execution flow, as blockchain operations are designed to execute in a deterministic and timely manner.

Second, achieving consensus among validators would be problematic. Validators would also need to invoke the same get method to verify a transaction's correctness. However, if the state of the target contract changes between these multiple invocations, validators could end up with differing versions of the transaction result.

Lastly, smart contracts in TON are designed to be pure functions: they will always produce the same output for the same input. This principle allows for straightforward consensus during message processing. Introducing runtime acquisition of arbitrary, dynamically changing data would break this deterministic property.

Implications for developers
These limitations mean that one contract cannot directly access the state of another contract via its get methods. While the inability to incorporate real-time, external data into a contract's deterministic flow might seem restrictive, it is precisely these constraints that ensure the integrity and reliability of blockchain technology.

Solutions and workarounds
In the TON Blockchain, smart contracts communicate through messages rather than directly invoking methods from one another. One can send a message to another contract requesting the execution of a specific method. These requests usually begin with special operation codes.

A contract designed to handle such requests will execute the specified method and return the results in a separate message. While this approach may seem complex, it effectively streamlines communication between contracts, enhancing the scalability and performance of the blockchain network.

This message-passing mechanism is integral to the TON Blockchain's operation, paving the way for scalable network growth without requiring extensive synchronization between shards.

For effective inter-contract communication, it is crucial to design your contracts so that they can properly accept and respond to requests. This involves implementing methods that can be invoked on-chain to return responses.

Let's consider a simple example:

#include "imports/stdlib.fc";

int get_total() method_id {
 return get_data().begin_parse().preload_uint(32);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
 if (in_msg_body.slice_bits() < 32) {
 return ();
 }

 slice cs = in_msg_full.begin_parse();
 cs~skip_bits(4);
 slice sender = cs~load_msg_addr();

 int op = in_msg_body~load_uint(32); ;; load the operation code

 if (op == 1) { ;; increase and update the number
 int number = in_msg_body~load_uint(32);
 int total = get_total();
 total += number;
 set_data(begin_cell().store_uint(total, 32).end_cell());
 }
 elseif (op == 2) { ;; query the number
 int total = get_total();
 send_raw_message(begin_cell()
 .store_uint(0x18, 6)
 .store_slice(sender)
 .store_coins(0)
 .store_uint(0, 107) ;; default message headers (see sending messages page)
 .store_uint(3, 32) ;; response operation code
 .store_uint(total, 32) ;; the requested number
 .end_cell(), 64);
 }
}


In this example, the contract receives and processes internal messages by interpreting operation codes, executing specific methods, and returning responses appropriately:

Op-code 1 denotes a request to update the number in the contract's data.
Op-code 2 signifies a request to query the number from the contract's data.
Op-code 3 is used in the response message, which the calling smart contract must handle to receive the result.
For simplicity, we used just simple little numbers 1, 2, and 3 for the operation codes. But for real projects, consider setting them according to the standard:

CRC32 hashes for op-codes
Common pitfalls and how to avoid them
Misuse of get methods: As mentioned earlier, get methods are designed to return data from the contract's state and are not meant to change the contract's state. Attempting to alter the contract's state within a get method will not do it.

Ignoring return types: Every get method must have a clearly defined return type that matches the retrieved data. If a method is expected to return a specific type of data, ensure that all execution paths within the method return this type. Inconsistent return types should be avoided, as they can lead to errors and complications when interacting with the contract.

Assuming cross-contract calls: A common misconception is that get methods can be called directly from other contracts on-chain. However, as previously discussed, this is not possible due to the inherent nature of blockchain technology and the requirement for consensus. Always remember that get methods are designed for off-chain use, while on-chain interactions between contracts are facilitated through internal messages.

Conclusion
Get methods are vital for querying data from smart contracts on the TON Blockchain. While they have certain limitations, understanding these constraints and learning how to work around them is crucial for effectively utilizing get methods in your smart contracts.

Most common get methods
Standard wallets
seqno()
int seqno() method_id {
 return get_data().begin_parse().preload_uint(32);
}

Returns the transaction's sequence number within a specific wallet. This method is primarily used for replay protection.

get_subwallet_id()
int get_subwallet_id() method_id {
 return get_data().begin_parse().skip_bits(32).preload_uint(32);
}

What is subwallet ID?
get_public_key()
int get_public_key() method_id {
 var cs = get_data().begin_parse().skip_bits(64);
 return cs.preload_uint(256);
}

This method retrieves the public key associated with the wallet.

Jettons
get_wallet_data()
(int, slice, slice, cell) get_wallet_data() method_id {
 return load_data();
}

This method returns the complete set of data associated with a jetton wallet:

(int) balance
(slice) owner_address
(slice) jetton_master_address
(cell) jetton_wallet_code
get_jetton_data()
(int, int, slice, cell, cell) get_jetton_data() method_id {
 (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();
 return (total_supply, -1, admin_address, content, jetton_wallet_code);
}


Returns data of a jetton master, including its total supply, the address of its admin, the content of the jetton, and its wallet code.

get_wallet_address(slice owner_address)
slice get_wallet_address(slice owner_address) method_id {
 (int total_supply, slice admin_address, cell content, cell jetton_wallet_code) = load_data();
 return calculate_user_jetton_wallet_address(owner_address, my_address(), jetton_wallet_code);
}


Given the owner's address, this method calculates and returns the address for the owner's jetton wallet contract.

NFTs
get_nft_data()
(int, int, slice, slice, cell) get_nft_data() method_id {
 (int init?, int index, slice collection_address, slice owner_address, cell content) = load_data();
 return (init?, index, collection_address, owner_address, content);
}


Returns the data associated with a non-fungible token, including whether it has been initialized, its index in a collection, the address of its collection, the owner's address, and its content.

get_collection_data()
(int, cell, slice) get_collection_data() method_id {
 var (owner_address, next_item_index, content, _, _) = load_data();
 slice cs = content.begin_parse();
 return (next_item_index, cs~load_ref(), owner_address);
}

Returns the data of an NFT collection, including the index of the next item available for minting, the content of the collection, and the owner's address.

get_nft_address_by_index(int index)
slice get_nft_address_by_index(int index) method_id {
 var (_, _, _, nft_item_code, _) = load_data();
 cell state_init = calculate_nft_item_state_init(index, nft_item_code);
 return calculate_nft_item_address(workchain(), state_init);
}

Given an index, this method calculates and returns the corresponding NFT item contract address within this collection.

royalty_params()
(int, int, slice) royalty_params() method_id {
 var (_, _, _, _, royalty) = load_data();
 slice rs = royalty.begin_parse();
 return (rs~load_uint(16), rs~load_uint(16), rs~load_msg_addr());
}

This method fetches the royalty parameters for an NFT. These parameters include the royalty percentage paid to the original creator whenever the NFT is sold.

get_nft_content(int index, cell individual_nft_content)
cell get_nft_content(int index, cell individual_nft_content) method_id {
 var (_, _, content, _, _) = load_data();
 slice cs = content.begin_parse();
 cs~load_ref();
 slice common_content = cs~load_ref().begin_parse();
 return (begin_cell()
 .store_uint(1, 8) ;; offchain tag
 .store_slice(common_content)
 .store_ref(individual_nft_content)
 .end_cell());
}

Given an index and individual NFT content, this method fetches and returns the NFT's combined common and individual content.

How to work with get methods
Calling get methods on popular explorers
Tonviewer
You can call get methods at the bottom of the page in the Methods tab.

https://tonviewer.com/EQAWrNGl875lXA6Fff7nIOwTIYuwiJMq0SmtJ5Txhgnz4tXI?section=method
Ton.cx
You can call get methods on the "Get methods" tab.

https://ton.cx/address/EQAWrNGl875lXA6Fff7nIOwTIYuwiJMq0SmtJ5Txhgnz4tXI
Calling get methods from code
We will use Javascript libraries and tools for the examples below:

ton library
Blueprint
Let's say there is some contract with the following get method:

(int) get_total() method_id {
 return get_data().begin_parse().preload_uint(32); ;; load and return the 32-bit number from the data
}


This method returns a single number loaded from the contract data.

You can use the code snippet below to call this get method on a contract deployed at a known address:

import { TonClient } from "@ton/ton";
import { Address } from "@ton/core";

async function main() {
  // Create Client
  const client = new TonClient({
    endpoint: "https://toncenter.com/api/v2/jsonRPC",
  });

  // Call get method
  const result = await client.runMethod(
    Address.parse("EQD4eA1SdQOivBbTczzElFmfiKu4SXNL4S29TReQwzzr_70k"),
    "get_total"
  );
  const total = result.stack.readNumber();
  console.log("Total:", total);
}

main();

This code will produce an output in the format Total: 123. The number may vary, as this is just an example.

Testing get methods
We can use the Sandbox to test smart contracts, which is installed by default in new Blueprint projects.

First, you must add a special method in the contract wrapper to execute the get method and return the typed result. Let's say your contract is called Counter, and you have already implemented the method to update the stored number. Open wrappers/Counter.ts and add the following method:

async getTotal(provider: ContractProvider) {
    const result = (await provider.get('get_total', [])).stack;
    return result.readNumber();
}

It executes the get method and retrieves the resulting stack. In this snippet, we read a single number from the stack. In more complex cases where multiple values are returned at once, you can simply call the readSomething type of method multiple times to parse the entire execution result from the stack.

Finally, we can use this method in our tests. Navigate to the tests/Counter.spec.ts and add a new test:

it("should return correct number from get method", async () => {
  const caller = await blockchain.treasury("caller");
  await counter.sendNumber(caller.getSender(), toNano("0.01"), 123);
  expect(await counter.getTotal()).toEqual(123);
});

You can check it by running npx blueprint test in your terminal. If you did everything correctly, this test should be marked as passed!

Invoking get methods from other contracts
Contrary to what might seem intuitive, invoking get methods from other contracts is impossible on-chain. This limitation stems primarily from the nature of blockchain technology and the need for consensus.

First, acquiring data from another ShardChain may introduce significant latency. Such delays could disrupt the contract execution flow, as blockchain operations are designed to execute in a deterministic and timely manner.

Second, achieving consensus among validators would be problematic. Validators would also need to invoke the same get method to verify a transaction's correctness. However, if the state of the target contract changes between these multiple invocations, validators could end up with differing versions of the transaction result.

Lastly, smart contracts in TON are designed to be pure functions: they will always produce the same output for the same input. This principle allows for straightforward consensus during message processing. Introducing runtime acquisition of arbitrary, dynamically changing data would break this deterministic property.

Implications for developers
These limitations mean that one contract cannot directly access the state of another contract via its get methods. While the inability to incorporate real-time, external data into a contract's deterministic flow might seem restrictive, it is precisely these constraints that ensure the integrity and reliability of blockchain technology.

Solutions and workarounds
In the TON Blockchain, smart contracts communicate through messages rather than directly invoking methods from one another. One can send a message to another contract requesting the execution of a specific method. These requests usually begin with special operation codes.

A contract designed to handle such requests will execute the specified method and return the results in a separate message. While this approach may seem complex, it effectively streamlines communication between contracts, enhancing the scalability and performance of the blockchain network.

This message-passing mechanism is integral to the TON Blockchain's operation, paving the way for scalable network growth without requiring extensive synchronization between shards.

For effective inter-contract communication, it is crucial to design your contracts so that they can properly accept and respond to requests. This involves implementing methods that can be invoked on-chain to return responses.

Let's consider a simple example:

#include "imports/stdlib.fc";

int get_total() method_id {
 return get_data().begin_parse().preload_uint(32);
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
 if (in_msg_body.slice_bits() < 32) {
 return ();
 }

 slice cs = in_msg_full.begin_parse();
 cs~skip_bits(4);
 slice sender = cs~load_msg_addr();

 int op = in_msg_body~load_uint(32); ;; load the operation code

 if (op == 1) { ;; increase and update the number
 int number = in_msg_body~load_uint(32);
 int total = get_total();
 total += number;
 set_data(begin_cell().store_uint(total, 32).end_cell());
 }
 elseif (op == 2) { ;; query the number
 int total = get_total();
 send_raw_message(begin_cell()
 .store_uint(0x18, 6)
 .store_slice(sender)
 .store_coins(0)
 .store_uint(0, 107) ;; default message headers (see sending messages page)
 .store_uint(3, 32) ;; response operation code
 .store_uint(total, 32) ;; the requested number
 .end_cell(), 64);
 }
}


In this example, the contract receives and processes internal messages by interpreting operation codes, executing specific methods, and returning responses appropriately:

Op-code 1 denotes a request to update the number in the contract's data.
Op-code 2 signifies a request to query the number from the contract's data.
Op-code 3 is used in the response message, which the calling smart contract must handle to receive the result.
For simplicity, we used just simple little numbers 1, 2, and 3 for the operation codes. But for real projects, consider setting them according to the standard:

CRC32 hashes for op-codes
Common pitfalls and how to avoid them
Misuse of get methods: As mentioned earlier, get methods are designed to return data from the contract's state and are not meant to change the contract's state. Attempting to alter the contract's state within a get method will not do it.

Ignoring return types: Every get method must have a clearly defined return type that matches the retrieved data. If a method is expected to return a specific type of data, ensure that all execution paths within the method return this type. Inconsistent return types should be avoided, as they can lead to errors and complications when interacting with the contract.

Assuming cross-contract calls: A common misconception is that get methods can be called directly from other contracts on-chain. However, as previously discussed, this is not possible due to the inherent nature of blockchain technology and the requirement for consensus. Always remember that get methods are designed for off-chain use, while on-chain interactions between contracts are facilitated through internal messages.

Conclusion
Get methods are vital for querying data from smart contracts on the TON Blockchain. While they have certain limitations, understanding these constraints and learning how to work around them is crucial for effectively utilizing get methods in your smart contracts.

Storefront bot with payments in TON
caution
The integration method described in this guide is one of the available approaches. With ongoing developments, Telegram Mini Apps provide additional capabilities that better suit modern security and functionality requirements.

In this article, we'll guide you through the process of accepting payments in a Telegram bot.

📖 What you'll learn
In this article, you'll learn how to:

Create a Telegram bot using Python and Aiogram,
Work with the public TON Center API,
Work with an SQlite database,
How to accept payments in a Telegram bot by applying the knowledge from previous steps.
📚 Before we begin
Make sure you have installed the latest version of Python and the following packages:

aiogram,
requests.
sqlite3.
🚀 Let's get started!
We'll follow this order:

Work with an SQlite database.
Work with the public TON API (TON Center).
Create a Telegram bot using Python and Aiogram.
Profit!
Let's create the following four files in our project directory:

telegram-bot
├── config.json
├── main.py
├── api.py
└── db.py

Config
In config.json, we store our bot token and public TON API key.

{
  "BOT_TOKEN": "Your bot token",
  "MAINNET_API_TOKEN": "Your mainnet api token",
  "TESTNET_API_TOKEN": "Your testnet api token",
  "MAINNET_WALLET": "Your mainnet wallet",
  "TESTNET_WALLET": "Your testnet wallet",
  "WORK_MODE": "testnet"
}

In config.json, define whether you'll use use Testnet or Mainnet.

Database
Create a database
This example uses a local Sqlite database.

Create a file called db.py.

To work with the database, import sqlite3 module and some modules for handling time.

import sqlite3
import datetime
import pytz

sqlite3—module for working with sqlite database,
datetime—module for working with time.
pytz—module for working with timezones.
Next, establish a connection to the database and a cursor:

locCon = sqlite3.connect('local.db', check_same_thread=False)
cur = locCon.cursor()

If the database does not exist, it will be created automatically.

We need two tables:

Transactions:
CREATE TABLE transactions (
    source  VARCHAR (48) NOT NULL,
    hash    VARCHAR (50) UNIQUE
                         NOT NULL,
    value   INTEGER      NOT NULL,
    comment VARCHAR (50)
);

source—payer's wallet address,
hash—transaction hash,
value—transaction value,
comment—transaction comment.
Users:
CREATE TABLE users (
    id         INTEGER       UNIQUE
                             NOT NULL,
    username   VARCHAR (33),
    first_name VARCHAR (300),
    wallet     VARCHAR (50)  DEFAULT none
);

id—Telegram user ID,
username—Telegram username,
first_name—Telegram user's first name,
wallet—user wallet address.
The users table stores Telegram users along with their Telegram ID, @username, first name, and wallet. The wallet is added to the database upon the first successful payment.

The transactions table stores verified transactions. To verify a transaction, we need a unique transaction hash, source, value, and comment.

To create these tables, we need to run the following function:

cur.execute('''CREATE TABLE IF NOT EXISTS transactions (
    source  VARCHAR (48) NOT NULL,
    hash    VARCHAR (50) UNIQUE
                        NOT NULL,
    value   INTEGER      NOT NULL,
    comment VARCHAR (50)
)''')
locCon.commit()

cur.execute('''CREATE TABLE IF NOT EXISTS users (
    id         INTEGER       UNIQUE
                            NOT NULL,
    username   VARCHAR (33),
    first_name VARCHAR (300),
    wallet     VARCHAR (50)  DEFAULT none
)''')
locCon.commit()

This code will create the tables if they are not already created.

Work with database
Let's analyze the process: A user makes a transaction. How do we verify it? How do we ensure that the same transaction isn't confirmed twice?

Each transaction includes a body_hash, which allows us to easily check whether the transaction is already in the database.

We only add transactions that have been verified. The check_transaction function determines whether a given transaction is already in the database.

add_v_transaction adds transaction to the transactions table.

def add_v_transaction(source, hash, value, comment):
    cur.execute("INSERT INTO transactions (source, hash, value, comment) VALUES (?, ?, ?, ?)",
                (source, hash, value, comment))
    locCon.commit()


def check_transaction(hash):
    cur.execute(f"SELECT hash FROM transactions WHERE hash = '{hash}'")
    result = cur.fetchone()
    if result:
        return True
    return False

check_user verifies if the user exists in the database and adds them if not.

def check_user(user_id, username, first_name):
    cur.execute(f"SELECT id FROM users WHERE id = '{user_id}'")
    result = cur.fetchone()

    if not result:
        cur.execute("INSERT INTO users (id, username, first_name) VALUES (?, ?, ?)",
                    (user_id, username, first_name))
        locCon.commit()
        return False
    return True


The user can store a wallet in the table. It is added with the first successful purchase. The v_wallet function checks if the user has an associated wallet. If not, it adds the wallet upon the user's first successful purchase.

def v_wallet(user_id, wallet):
    cur.execute(f"SELECT wallet FROM users WHERE id = '{user_id}'")
    result = cur.fetchone()
    if result[0] == "none":
        cur.execute(
            f"UPDATE users SET wallet = '{wallet}' WHERE id = '{user_id}'")
        locCon.commit()
        return True
    else:
        return result[0]


get_user_wallet simply retrieves the user's wallet.

def get_user_wallet(user_id):
    cur.execute(f"SELECT wallet FROM users WHERE id = '{user_id}'")
    result = cur.fetchone()
    return result[0]

get_user_payments returns the user's payment history. This function checks if the user has a wallet. If they do, it provides the list of their payments.

def get_user_payments(user_id):
    wallet = get_user_wallet(user_id)

    if wallet == "none":
        return "You have no wallet"
    else:
        cur.execute(f"SELECT * FROM transactions WHERE source = '{wallet}'")
        result = cur.fetchall()
        tdict = {}
        tlist = []
        try:
            for transaction in result:
                tdict = {
                    "value": transaction[2],
                    "comment": transaction[3],
                }
                tlist.append(tdict)
            return tlist

        except:
            return False


API
We can interact with the blockchain using third-party APIs provided by network members. These services allow developers to bypass the need their own node and customize their API.

Required requests
What do we need to confirm that a user has transferred the required amount?

We simply need to check the latest incoming transfers to our wallet and find a transaction from the right address with the right amount (and possibly a unique comment). For this, TON Center provides the getTransactions method.

getTransactions
By default, this method retrieves the last 10 transactions. However, we can request more, though this slightly increases the response time. In most cases, requestin additional transactions is unnecessary.

If more transactions are required, each transaction includes lt and hash. We can fetch, for example, the last 30 transactions. If the required transaction is not found, we can take lt and hash of the last transaction in the list and include them in a new request.

This allows us to retrieve the next 30 transactions, and so on.

For example, consider the wallet in the test network EQAVKMzqtrvNB2SkcBONOijadqFZ1gMdjmzh1Y3HB1p_zai5.

Using a query returns a response containing two transactions. Note that some details have been omitted for clarity.

{
  "ok": true,
  "result": [
    {
      "transaction_id": {
        "lt": "1944556000003",
        "hash": "swpaG6pTBXwYI2024NAisIFp59Fw3k1DRQ5fa5SuKAE="
      },
      "in_msg": {
        "source": "EQCzQJJBAQ-FrEFcvxO5sNxhV9CaOdK9CCfq2yCBnwZ4aJ9R",
        "destination": "EQAVKMzqtrvNB2SkcBONOijadqFZ1gMdjmzh1Y3HB1p_zai5",
        "value": "1000000000",
        "body_hash": "kBfGYBTkBaooeZ+NTVR0EiVGSybxQdb/ifXCRX5O7e0=",
        "message": "Sea breeze 🌊"
      },
      "out_msgs": []
    },
    {
      "transaction_id": {
        "lt": "1943166000003",
        "hash": "hxIQqn7lYD/c/fNS7W/iVsg2kx0p/kNIGF6Ld0QEIxk="
      },
      "in_msg": {
        "source": "EQCzQJJBAQ-FrEFcvxO5sNxhV9CaOdK9CCfq2yCBnwZ4aJ9R",
        "destination": "EQAVKMzqtrvNB2SkcBONOijadqFZ1gMdjmzh1Y3HB1p_zai5",
        "value": "1000000000",
        "body_hash": "7iirXn1RtliLnBUGC5umIQ6KTw1qmPk+wwJ5ibh9Pf0=",
        "message": "Spring forest 🌲"
      },
      "out_msgs": []
    }
  ]
}

By adding lt and hash to the query, we can retrieve the next two two transactions in sequence. That is, instead of getting the first and second transactions, we will receive the second and third.

{
  "ok": true,
  "result": [
    {
      "transaction_id": {
        "lt": "1943166000003",
        "hash": "hxIQqn7lYD/c/fNS7W/iVsg2kx0p/kNIGF6Ld0QEIxk="
      },
      "in_msg": {
        "source": "EQCzQJJBAQ-FrEFcvxO5sNxhV9CaOdK9CCfq2yCBnwZ4aJ9R",
        "destination": "EQAVKMzqtrvNB2SkcBONOijadqFZ1gMdjmzh1Y3HB1p_zai5",
        "value": "1000000000",
        "body_hash": "7iirXn1RtliLnBUGC5umIQ6KTw1qmPk+wwJ5ibh9Pf0=",
        "message": "Spring forest 🌲"
      },
      "out_msgs": []
    },
    {
      "transaction_id": {
        "lt": "1845458000003",
        "hash": "k5U9AwIRNGhC10hHJ3MBOPT//bxAgW5d9flFiwr1Sao="
      },
      "in_msg": {
        "source": "EQCzQJJBAQ-FrEFcvxO5sNxhV9CaOdK9CCfq2yCBnwZ4aJ9R",
        "destination": "EQAVKMzqtrvNB2SkcBONOijadqFZ1gMdjmzh1Y3HB1p_zai5",
        "value": "1000000000",
        "body_hash": "XpTXquHXP64qN6ihHe7Tokkpy88tiL+5DeqIrvrNCyo=",
        "message": "Second"
      },
      "out_msgs": []
    }
  ]
}

The request will look like as follows this.

We will also need a method detectAddress.

Here is an example of a Tonkeeper wallet address on Testnet: kQCzQJJBAQ-FrEFcvxO5sNxhV9CaOdK9CCfq2yCBnwZ4aCTb. If we look for the transaction in the explorer, the address appears as: EQCzQJJBAQ-FrEFcvxO5sNxhV9CaOdK9CCfq2yCBnwZ4aJ9R.

This method provides us with the correctly formatted address.

{
  "ok": true,
  "result": {
    "raw_form": "0:b3409241010f85ac415cbf13b9b0dc6157d09a39d2bd0827eadb20819f067868",
    "bounceable": {
      "b64": "EQCzQJJBAQ+FrEFcvxO5sNxhV9CaOdK9CCfq2yCBnwZ4aJ9R",
      "b64url": "EQCzQJJBAQ-FrEFcvxO5sNxhV9CaOdK9CCfq2yCBnwZ4aJ9R"
    },
    "non_bounceable": {
      "b64": "UQCzQJJBAQ+FrEFcvxO5sNxhV9CaOdK9CCfq2yCBnwZ4aMKU",
      "b64url": "UQCzQJJBAQ-FrEFcvxO5sNxhV9CaOdK9CCfq2yCBnwZ4aMKU"
    }
  }
}


Additionally, we need b64url, which allows us to validate the user's address.

Basically, that's all we need.

API requests and what to do with them
Now, let's move to the IDE andreate the api.py file.

Import the necessary libraries.

import requests
import json
# We import our db module, as it will be convenient to add from here
# transactions to the database
import db

requests—to make requests to the API,
json—to work with JSON,
db—to work with our sqlite database.
Let's create two variables to store the base URLs for our requests.

# This is the beginning of our requests
MAINNET_API_BASE = "https://toncenter.com/api/v2/"
TESTNET_API_BASE = "https://testnet.toncenter.com/api/v2/"

We get all API tokens and wallets from the config.json file.

# Find out which network we are working on
with open('config.json', 'r') as f:
    config_json = json.load(f)
    MAINNET_API_TOKEN = config_json['MAINNET_API_TOKEN']
    TESTNET_API_TOKEN = config_json['TESTNET_API_TOKEN']
    MAINNET_WALLET = config_json['MAINNET_WALLET']
    TESTNET_WALLET = config_json['TESTNET_WALLET']
    WORK_MODE = config_json['WORK_MODE']

Depending on the network, we take the necessary data.

if WORK_MODE == "mainnet":
    API_BASE = MAINNET_API_BASE
    API_TOKEN = MAINNET_API_TOKEN
    WALLET = MAINNET_WALLET
else:
    API_BASE = TESTNET_API_BASE
    API_TOKEN = TESTNET_API_TOKEN
    WALLET = TESTNET_WALLET

Our first request function detectAddress.

def detect_address(address):
    url = f"{API_BASE}detectAddress?address={address}&api_key={API_TOKEN}"
    r = requests.get(url)
    response = json.loads(r.text)
    try:
        return response['result']['bounceable']['b64url']
    except:
        return False

At the input, we have the estimated address, and at the output, we have either the "correct" address necessary for us to do further work or False.

You may notice that an API key has appeared at the end of the request. It is needed to remove the limit on the number of requests to the API. Without it, we are limited to one request per second.

Here is next function for getTransactions:

def get_address_transactions():
    url = f"{API_BASE}getTransactions?address={WALLET}&limit=30&archival=true&api_key={API_TOKEN}"
    r = requests.get(url)
    response = json.loads(r.text)
    return response['result']


This function returns the last 30 transactions for our WALLET.

The archival=true parameter ensures that transactions are retrieved from a node with a complete blockchain history.

At the output, we get a list of transactions, such as [{0},{1},...,{29}] which are represented as a list of dictionaries. And finally the last function:

def find_transaction(user_wallet, value, comment):
		# Get the last 30 transactions
    transactions = get_address_transactions()
    for transaction in transactions:
				# Select the incoming "message" - transaction
        msg = transaction['in_msg']
        if msg['source'] == user_wallet and msg['value'] == value and msg['message'] == comment:
						# If all the data match, we check that this transaction
						# we have not verified before
            t = db.check_transaction(msg['body_hash'])
            if t == False:
								# If not, we write in the table to the verified
								# and return True
                db.add_v_transaction(
                    msg['source'], msg['body_hash'], msg['value'], msg['message'])
                print("find transaction")
                print(
                    f"transaction from: {msg['source']} \nValue: {msg['value']} \nComment: {msg['message']}")
                return True
						# If this transaction is already verified, we check the rest, we can find the right one
            else:
                pass
		# If the last 30 transactions do not contain the required one, return False
		# Here you can add code to see the next 29 transactions
		# However, within the scope of the Example, this would be redundant.
    return False


At the input, we get the correct wallet address, amount and comment. If the expected incoming transaction is found, the output is True; otherwise, it is False.

Telegram bot
First, let's establish the bot's foundation.

Imports
In this part, we will import the required libraries.

From aiogram we need Bot, Dispatcher, types and executor.

from aiogram import Bot, Dispatcher, executor, types

MemoryStorage is needed for the temporary storage of information.

FSMContext, State, and StatesGroup are needed for working with the state machine.

from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup

json is needed to work with json files. logging is needed to log errors.

import json
import logging

api and db are our own files which we will fill in later.

import db
import api

Config setup
It is recommended to store data such as BOT_TOKEN and wallet addresses for receiving payments in a separate file called config.json for convenience.

{
  "BOT_TOKEN": "Your bot token",
  "MAINNET_API_TOKEN": "Your mainnet api token",
  "TESTNET_API_TOKEN": "Your testnet api token",
  "MAINNET_WALLET": "Your mainnet wallet",
  "TESTNET_WALLET": "Your testnet wallet",
  "WORK_MODE": "testnet"
}

Bot token
BOT_TOKEN is the Telegram bot token obtained from @BotFather

Working mode
The WORK_MODE key defines whether the bot operates in the test or main network; testnet or mainnet respectively.

API tokens
API tokens for *_API_TOKEN can be obtained from the TON Center bots:

Mainnet — @tonapibot
Testnet — @tontestnetapibot
Connecting the config to our bot
Next, we complete the bot setup by retrieving the bot token from config.json :

with open('config.json', 'r') as f:
    config_json = json.load(f)
    BOT_TOKEN = config_json['BOT_TOKEN']
		# put wallets here to receive payments
    MAINNET_WALLET = config_json['MAINNET_WALLET']
    TESTNET_WALLET = config_json['TESTNET_WALLET']
    WORK_MODE = config_json['WORK_MODE']

if WORK_MODE == "mainnet":
    WALLET = MAINNET_WALLET
else:
		# By default, the bot will run on the testnet
    WALLET = TESTNET_WALLET

Logging and bot setup
logging.basicConfig(level=logging.INFO)
bot = Bot(token=BOT_TOKEN, parse_mode=types.ParseMode.HTML)
dp = Dispatcher(bot, storage=MemoryStorage())

States
States allow us to devide the bot workflow into stages, each designated for a specific task.

class DataInput (StatesGroup):
    firstState = State()
    secondState = State()
    WalletState = State()
    PayState = State()

For details and examples, refer to the Aiogram documentation.

Message handlers
This is the part where we will write the bot interaction logic.

We'll be using two types of handlers:

message_handler is used to handle messages from users,
callback_query_handler is used to handle callbacks from inline keyboards.
If we want to handle a message from the user, we will use message_handler by placing @dp.message_handler decorator above the function. In this case, the function will be called when the user sends a message to the bot.

In the decorator, we can specify the conditions under which the function will be called. For example, if we want the function to be called only when the user sends a message with the text /start, then we will write the following:

@dp.message_handler(commands=['start'])

Handlers need to be assigned to an async function. In this case, we will use async def syntax. The async def syntax is used to define the function that will be called asynchronously.

/start
Let's start with /start command handler.

@dp.message_handler(commands=['start'], state='*')
async def cmd_start(message: types.Message):
    await message.answer(f"WORKMODE: {WORK_MODE}")
    # check if user is in database. if not, add him
    isOld = db.check_user(
        message.from_user.id, message.from_user.username, message.from_user.first_name)
    # if user already in database, we can address him differently
    if isOld == False:
        await message.answer(f"You are new here, {message.from_user.first_name}!")
        await message.answer(f"to buy air send /buy")
    else:
        await message.answer(f"Welcome once again, {message.from_user.first_name}!")
        await message.answer(f"to buy more air send /buy")
    await DataInput.firstState.set()


In the decorator of a handler, you may see state='*', meaning the handler will be triggered regardless of the bot's state. If we want the handler to activate only in a specific state, we specify it, such as state=DataInput.firstState, ensuring the handler runs only when the bot is in firstState.

After the user sends /start command, the bot will check if the user is in database using db.check_user function. If not, it will add him. This function will also return the bool value and we can use it to address the user differently. After that, the bot will set the state to firstState.

/cancel
The /cancel command returns the bot to firstState.

@dp.message_handler(commands=['cancel'], state="*")
async def cmd_cancel(message: types.Message):
    await message.answer("Canceled")
    await message.answer("/start to restart")
    await DataInput.firstState.set()

/buy
And, of course, there is a /buy command handler. In this example, we sell different types of air and use the reply keyboard to choose the type.

# /buy command handler
@dp.message_handler(commands=['buy'], state=DataInput.firstState)
async def cmd_buy(message: types.Message):
    # reply keyboard with air types
    keyboard = types.ReplyKeyboardMarkup(
        resize_keyboard=True, one_time_keyboard=True)
    keyboard.add(types.KeyboardButton('Just pure 🌫'))
    keyboard.add(types.KeyboardButton('Spring forest 🌲'))
    keyboard.add(types.KeyboardButton('Sea breeze 🌊'))
    keyboard.add(types.KeyboardButton('Fresh asphalt 🛣'))
    await message.answer(f"Choose your air: (or /cancel)", reply_markup=keyboard)
    await DataInput.secondState.set()


So, when a user sends /buy command, the bot sends him a reply keyboard with air types. After the user chooses the type of air, the bot will set the state to secondState.

This handler will work only when secondState is set and will be waiting for a message from the user with the air type. In this case, we need to store the air type that the user choses, so we pass FSMContext as an argument to the function.

FSMContext is used to store data in the bot's memory. We can store any data in it but this memory is not persistent, so if the bot is restarted, the data will be lost. But it's good to store temporary data in it.

# handle air type
@dp.message_handler(state=DataInput.secondState)
async def air_type(message: types.Message, state: FSMContext):
    if message.text == "Just pure 🌫":
        await state.update_data(air_type="Just pure 🌫")
    elif message.text == "Fresh asphalt 🛣":
        await state.update_data(air_type="Fresh asphalt 🛣")
    elif message.text == "Spring forest 🌲":
        await state.update_data(air_type="Spring forest 🌲")
    elif message.text == "Sea breeze 🌊":
        await state.update_data(air_type="Sea breeze 🌊")
    else:
        await message.answer("Wrong air type")
        await DataInput.secondState.set()
        return
    await DataInput.WalletState.set()
    await message.answer(f"Send your wallet address")

Use...

await state.update_data(air_type="Just pure 🌫")

...to store the air type in FSMContext. After that, we set the state to WalletState and ask the user to send their wallet address.

This handler activates only in WalletState, expecting a valid wallet address.

Consider the next handler. It may seem complex, but it isn’t. First, we verify whether the message contains a wallet address of the correct length using len(message.text) == 48. Then, we call the api.detect_address function to validate the address. This function also returns the standardized correct address, which is stored in the database.

After that, we get the air type from FSMContext using await state.get_data() and store it in user_data variable.

Now we have all the data required for the payment process. We just need to generate a payment link and send it to the user. Let's use the inline keyboard.

The bot provides three payment buttons:

TON wallet,
Tonhub,
Tonkeeper.
These buttons are advantageous of special buttons because they guide users to install a wallet if they don't have one

You are free to use whatever you want.

And we need a button that the user will press after tmaking a transaction, allowing the bot to verify the payment.

@dp.message_handler(state=DataInput.WalletState)
async def user_wallet(message: types.Message, state: FSMContext):
    if len(message.text) == 48:
        res = api.detect_address(message.text)
        if res == False:
            await message.answer("Wrong wallet address")
            await DataInput.WalletState.set()
            return
        else:
            user_data = await state.get_data()
            air_type = user_data['air_type']
            # inline button "check transaction"
            keyboard2 = types.InlineKeyboardMarkup(row_width=1)
            keyboard2.add(types.InlineKeyboardButton(
                text="Check transaction", callback_data="check"))
            keyboard1 = types.InlineKeyboardMarkup(row_width=1)
            keyboard1.add(types.InlineKeyboardButton(
                text="Ton Wallet", url=f"ton://transfer/{WALLET}?amount=1000000000&text={air_type}"))
            keyboard1.add(types.InlineKeyboardButton(
                text="Tonkeeper", url=f"https://app.tonkeeper.com/transfer/{WALLET}?amount=1000000000&text={air_type}"))
            keyboard1.add(types.InlineKeyboardButton(
                text="Tonhub", url=f"https://tonhub.com/transfer/{WALLET}?amount=1000000000&text={air_type}"))
            await message.answer(f"You choose {air_type}")
            await message.answer(f"Send <code>1</code> toncoin to address \n<code>{WALLET}</code> \nwith comment \n<code>{air_type}</code> \nfrom your wallet ({message.text})", reply_markup=keyboard1)
            await message.answer(f"Click the button after payment", reply_markup=keyboard2)
            await DataInput.PayState.set()
            await state.update_data(wallet=res)
            await state.update_data(value_nano="1000000000")
    else:
        await message.answer("Wrong wallet address")
        await DataInput.WalletState.set()


/me
One last message handler is /me. It shows the user's payments.

# /me command handler
@dp.message_handler(commands=['me'], state="*")
async def cmd_me(message: types.Message):
    await message.answer(f"Your transactions")
    # db.get_user_payments returns list of transactions for user
    transactions = db.get_user_payments(message.from_user.id)
    if transactions == False:
        await message.answer(f"You have no transactions")
    else:
        for transaction in transactions:
            # we need to remember that blockchain stores value in nanotons. 1 toncoin = 1000000000 in blockchain
            await message.answer(f"{int(transaction['value'])/1000000000} - {transaction['comment']}")


Callback handlers
Callback data is embedded in buttons, allowing the bot to recognize user actions.

For example, the “Payment Confirmed” button sends the callback "check", which the bot must process.

Callback handlers are very similar to message handlers but they have types.CallbackQuery as an argument instead of message. Function decorator is also different.

@dp.callback_query_handler(lambda call: call.data == "check", state=DataInput.PayState)
async def check_transaction(call: types.CallbackQuery, state: FSMContext):
    # send notification
    user_data = await state.get_data()
    source = user_data['wallet']
    value = user_data['value_nano']
    comment = user_data['air_type']
    result = api.find_transaction(source, value, comment)
    if result == False:
        await call.answer("Wait a bit, try again in 10 seconds. You can also check the status of the transaction through the explorer (tonscan.org/)", show_alert=True)
    else:
        db.v_wallet(call.from_user.id, source)
        await call.message.edit_text("Transaction is confirmed \n/start to restart")
        await state.finish()
        await DataInput.firstState.set()


In this handler we get user data from FSMContext and use api.find_transaction to check if the transaction was successful. If so, the wallet address is stored in the database, and the bot notifies the user. After that, the user can check their transaction anytime using /me.

Finalizing main.py
At the end, don't forget:

if __name__ == '__main__':
    executor.start_polling(dp, skip_updates=True)

This part is needed to start the bot. In skip_updates=True we specify that we do not want to process old messages. But if you want to process all messages, you can set it to False.

info
All code of main.py can be found here.

Bot in action
Congratulations! The bot is ready. You can test it!

Steps to run the bot:

Fill in the config.json file.
Run main.py.
All files must be in the same folder. To start the bot, you need to run the main.py file. You can do it in your IDE or in the terminal like this:

python main.py

If errors occur, check them in the terminal. Maybe you have missed something in the code.

Example of a working bot @AirDealerBot

bot

Step by step NFT collection minting
👋 Introduction
Non-fungible tokens (NFTs) have become one of the hottest topics in the world of digital art and collectibles. NFTs are unique digital assets that use blockchain technology to verify ownership and authenticity. They have opened new possibilities for creators and collectors to monetize and trade digital art, music, videos, and other forms of digital content. In recent years, the NFT market has exploded, with some high-profile sales reaching millions of dollars. In this article, we will build an NFT collection on TON step by step.

This is the beautiful collection of ducks you will create by the end of this tutorial:



🦄 What you will learn
You will mint an NFT collection on TON.
You will understand how NFTs on TON work.
You will put an NFT on sale.
You will upload metadata to pinata.cloud.
💡 Prerequisites
You must already have a testnet wallet with at least 2 TON. You can get testnet coins from @testgiver_ton_bot.

How to use the testnet on my Tonkeeper wallet?
Open Wallets list.
Create a new Testnet wallet: Add wallet → Add Testnet Account.
We will use Pinata as our IPFS storage system, so you also need to create an account on pinata.cloud and get api_key and api_secret. The official Pinata documentation can help with that. Once you have these API tokens, I’ll be waiting for you here!

💎 What is an NFT on TON?
Before starting the main part of our tutorial, we need to understand how NFTs work on TON. Unexpectedly, we will first explain of how NFTs work on Ethereum (ETH), to highlight the uniqueness of NFT implementation on TON compared to other blockchains.

NFT implementation on ETH
The implementation of the NFT in ETH is extremely simple. There is 1 main contract for the collection, which stores a simple hashmap containing the NFT data for that collection. All requests related to this collection (such as transferring an NFT, putting it up for sale, etc.) are sent directly to the single contract.



Problems with such implementation on TON
The NFT standard in TON describes the issues of using this model:

Unpredictable gas consumption. In TON, gas consumption for dictionary operations depends on exact set of keys. TON is an asynchronous blockchain, meaning you cannot predict how many messages from other users will reach a smart contract before yours. This uncertainty makes it difficult to determine gas costs, especially in smart contract chains like wallet → NFT smart contract → auction → NFT smart contract. If gas costs cannot be predicted, issues may arise where ownership of the NFT smart contract changes, but there are not enough Toncoins for the auction operation. Using smart contracts without dictionaries allows for deterministic gas consumption.

Scalability issues (becomes a bottleneck). TON scales through sharding, which partitions the network into shardchains under load. A single, large smart contract for a popular NFT contradicts this concept because many transactions would refer to one contract, creating a bottleneck. Although TON supports sharded smart contracts (see the whitepaper), they are not yet implemented.

TL;DR The ETH solution is not scalable and is unsuitable for an asynchronous blockchain like TON.

TON NFT implementation
On TON, there is one master contract—the collection’s smart contract—which stores its metadata, the owner's address, and, most importantly, the logic for minting new NFTs. To create ("mint") a new NFT, you simply send a message to the collection contract. This contract then deploys a new NFT item contract using the data you provide.



info
You can check out the article on NFT processing on TON or read the NFT standard for a deeper understanding.

⚙ Setup development environment
Let's start by creating an empty project:

Create a new folder
mkdir MintyTON

Open this folder
cd MintyTON

Initialize the project
yarn init -y

Install TypeScript
yarn add typescript @types/node -D

Initialize the TypeScript project
tsc --init

Copy this configuration into tsconfig.json
{
    "compilerOptions": {
      "module": "commonjs",
      "target": "es6",
      "lib": ["ES2022"],
      "moduleResolution": "node",
      "sourceMap": true,
      "outDir": "dist",
      "baseUrl": "src",
      "emitDecoratorMetadata": true,
      "experimentalDecorators": true,
      "strict": true,
      "esModuleInterop": true,
      "strictPropertyInitialization": false
    },
    "include": ["src/**/*"]
}

Add a script to build & start the app in package.json
"scripts": {
    "start": "tsc --skipLibCheck && node dist/app.js"
  },

Install required libraries
yarn add @pinata/sdk dotenv @ton/ton @ton/crypto @ton/core buffer

Create a .env file and add your own data based on this template
PINATA_API_KEY=your_api_key
PINATA_API_SECRET=your_secret_api_key
MNEMONIC=word1 word2 word3 word4
TONCENTER_API_KEY=aslfjaskdfjasasfas

You can get a TON Center API key from @tonapibot and choose mainnet or testnet. Store the 24-word seed phrase of the collection owner’s wallet in the MNEMONIC variable.

Great! Now we are ready to start writing code for our project.

Write helper functions
First, let's create the openWallet function in src/utils.ts. This function will open our wallet using a mnemonic and return its publicKey/secretKey.

We get a pair of keys based on 24 words (a seed phrase):

import { KeyPair, mnemonicToPrivateKey } from "@ton/crypto";
import { beginCell, Cell, OpenedContract} from "@ton/core";
import { TonClient, WalletContractV4 } from "@ton/ton";

export type OpenedWallet = {
  contract: OpenedContract<WalletContractV4>;
  keyPair: KeyPair;
};

export async function openWallet(mnemonic: string[], testnet: boolean) {
  const keyPair = await mnemonicToPrivateKey(mnemonic);

Create a class instance to interact with toncenter:

  const toncenterBaseEndpoint: string = testnet
    ? "https://testnet.toncenter.com"
    : "https://toncenter.com";

  const client = new TonClient({
    endpoint: `${toncenterBaseEndpoint}/api/v2/jsonRPC`,
    apiKey: process.env.TONCENTER_API_KEY,
  });

Finally, open our wallet:

  const wallet = WalletContractV4.create({
      workchain: 0,
      publicKey: keyPair.publicKey,
    });

  const contract = client.open(wallet);
  return { contract, keyPair };
}

Nice! After that, we'll create the main entry point for our project—src/app.ts. Here, we will use the newly created openWallet function and call our main function, init. Thats enough for now.

import * as dotenv from "dotenv";

import { openWallet } from "./utils";
import { readdir } from "fs/promises";

dotenv.config();

async function init() {
  const wallet = await openWallet(process.env.MNEMONIC!.split(" "), true);  
}

void init();


Next, let's create a delay.ts file in the src directory, which will contain a function that waits until seqno increases.

import { OpenedWallet } from "./utils";

export async function waitSeqno(seqno: number, wallet: OpenedWallet) {
  for (let attempt = 0; attempt < 10; attempt++) {
    await sleep(2000);
    const seqnoAfter = await wallet.contract.getSeqno();
    if (seqnoAfter == seqno + 1) break;
  }
}

export function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

What is it - seqno?
Simply put, seqno is a counter that tracks outgoing transactions from a wallet. It helps prevent Replay Attacks. hen a transaction is sent to a wallet smart contract, it compares the seqno field in the transaction with the one stored in the wallet. If they match, the transaction is accepted, and the stored seqno increments by one. If they don't match, the transaction is discarded. This is why we need to wait a bit after every outgoing transaction.

🖼 Prepare metadata
Metadata is simple information that describes an NFT or an NFT collection (e.g., name, description, etc.).

First, we need to store NFT images in /data/images/ and name them 0.png, 1.png, ... for photos, and logo.png for avatars of our collection. You can either download pack of ducks images or use your own images. Store metadata files in /data/metadata/.

NFT specifications
Most projects on TON follow these metadata specifications for NFT collections:

Name	Explanation
name	Collection name
description	Collection description
image	Link to the avatar image. Supported formats: https, ipfs, TON Storage.
cover_image	Link to the collection cover image.
social_links	List of up to 10 links to the project's social media profiles.
image

Based on this, let's create our own metadata file, collection.json, to describe the NFT collection!

{
  "name": "Ducks on TON",
  "description": "This collection is created for showing an example of minting NFT collection on TON. You can support creator by buying one of this NFT.",
  "social_links": ["https://t.me/DucksOnTON"]
}


Note: We’re not adding the "image" parameter just yet—you’ll see why later!

Once done, you can create as many NFT metadata files as you like.

Each NFT item follows these metadata specifications:

Name	Explanation
name	NFT name. Recommended length: 15-30 characters
description	NFT description. Recommended length: Up to 500 characters
image	Link to the NFT image.
attributes	List of NFT attributes, where a trait_type (attribute name) and value (a short description) are specified.
lottie	Link to a JSON file with Lottie animation (if specified, the animation will play on the NFT’s page).
content_url	Link to additional content.
content_type	Type of content from the content_url link (e.g., video/mp4).
image

{
  "name": "Duck #00",
  "description": "What about a round of golf?",
  "attributes": [{ "trait_type": "Awesomeness", "value": "Super cool" }]
}

After that, you can create as many files of an NFT item with their metadata as you want.

Upload metadata
Now let's write some code, that will upload our metadata files to IPFS. Create a metadata.ts file in src directory and add all needed imports:

import pinataSDK from "@pinata/sdk";
import { readdirSync } from "fs";
import { writeFile, readFile } from "fs/promises";
import path from "path";

After that, we need to create a function that will actually upload all files from our folder to IPFS:

export async function uploadFolderToIPFS(folderPath: string): Promise<string> {
  const pinata = new pinataSDK({
    pinataApiKey: process.env.PINATA_API_KEY,
    pinataSecretApiKey: process.env.PINATA_API_SECRET,
  });

  const response = await pinata.pinFromFS(folderPath);
  return response.IpfsHash;
}


Great! Back to the question at hand: why did we leave the "image" field in the metadata files empty? Imagine a situation where you want to create 1000 NFTs in your collection and, accordingly, you have to manually go through each item and manually insert a link to your image. This is really inconvenient and wrong, so let's write a function that will do this automatically!

export async function updateMetadataFiles(metadataFolderPath: string, imagesIpfsHash: string): Promise<void> {
  const files = readdirSync(metadataFolderPath);

  await Promise.all(files.map(async (filename, index) => {
    const filePath = path.join(metadataFolderPath, filename)
    const file = await readFile(filePath);
    
    const metadata = JSON.parse(file.toString());
    metadata.image =
      index != files.length - 1
        ? `ipfs://${imagesIpfsHash}/${index}.jpg`
        : `ipfs://${imagesIpfsHash}/logo.jpg`;
    
    await writeFile(filePath, JSON.stringify(metadata));
  }));
}


Here we first read all of the files in the specified folder:

const files = readdirSync(metadataFolderPath);

Iterate over each file and get its content

const filePath = path.join(metadataFolderPath, filename)
const file = await readFile(filePath);

const metadata = JSON.parse(file.toString());

After that, we assign the value ipfs://{IpfsHash}/{index}.jpg to the image field. If this file is mnot the last one in the folder, assign ipfs://{imagesIpfsHash}/logo.jpg and rewrite the file with new data.

Full code of metadata.ts:

import pinataSDK from "@pinata/sdk";
import { readdirSync } from "fs";
import { writeFile, readFile } from "fs/promises";
import path from "path";

export async function uploadFolderToIPFS(folderPath: string): Promise<string> {
  const pinata = new pinataSDK({
    pinataApiKey: process.env.PINATA_API_KEY,
    pinataSecretApiKey: process.env.PINATA_API_SECRET,
  });

  const response = await pinata.pinFromFS(folderPath);
  return response.IpfsHash;
}

export async function updateMetadataFiles(metadataFolderPath: string, imagesIpfsHash: string): Promise<void> {
  const files = readdirSync(metadataFolderPath);

  files.forEach(async (filename, index) => {
    const filePath = path.join(metadataFolderPath, filename)
    const file = await readFile(filePath);
    
    const metadata = JSON.parse(file.toString());
    metadata.image =
      index != files.length - 1
        ? `ipfs://${imagesIpfsHash}/${index}.jpg`
        : `ipfs://${imagesIpfsHash}/logo.jpg`;
    
    await writeFile(filePath, JSON.stringify(metadata));
  });
}


Great, let's call these methods in our app.ts file. Add the imports of our functions:

import { updateMetadataFiles, uploadFolderToIPFS } from "./src/metadata";

Save the variables with the path to the metadata/images folder and call our functions to load the metadata.

async function init() {
  const metadataFolderPath = "./data/metadata/";
  const imagesFolderPath = "./data/images/";

  const wallet = await openWallet(process.env.MNEMONIC!.split(" "), true);

  console.log("Started uploading images to IPFS...");
  const imagesIpfsHash = await uploadFolderToIPFS(imagesFolderPath);
  console.log(
    `Successfully uploaded the pictures to ipfs: https://gateway.pinata.cloud/ipfs/${imagesIpfsHash}`
  );

  console.log("Started uploading metadata files to IPFS...");
  await updateMetadataFiles(metadataFolderPath, imagesIpfsHash);
  const metadataIpfsHash = await uploadFolderToIPFS(metadataFolderPath);
  console.log(
    `Successfully uploaded the metadata to ipfs: https://gateway.pinata.cloud/ipfs/${metadataIpfsHash}`
  );
}


After that you can run yarn start and see the link to your deployed metadata!

Encode offchain content
How will our metadata files stored in the smart contract be referenced? This question can be fully answered by the Token Data Standart. In some cases, it is not enough to simply provide the desired flag and the link as ASCII characters. That is why let's consider splitting our link into several parts using the snake format.

First, create the function in ./src/utils.ts. The function that will convert our buffer into chunks:

function bufferToChunks(buff: Buffer, chunkSize: number) {
  const chunks: Buffer[] = [];
  while (buff.byteLength > 0) {
    chunks.push(buff.subarray(0, chunkSize));
    buff = buff.subarray(chunkSize);
  }
  return chunks;
}

And create a function that will bind all the chunks into 1 snake-cell:

function makeSnakeCell(data: Buffer): Cell {
  const chunks = bufferToChunks(data, 127);

  if (chunks.length === 0) {
    return beginCell().endCell();
  }

  if (chunks.length === 1) {
    return beginCell().storeBuffer(chunks[0]).endCell();
  }

  let curCell = beginCell();

  for (let i = chunks.length - 1; i >= 0; i--) {
    const chunk = chunks[i];

    curCell.storeBuffer(chunk);

    if (i - 1 >= 0) {
      const nextCell = beginCell();
      nextCell.storeRef(curCell);
      curCell = nextCell;
    }
  }

  return curCell.endCell();
}

Finally, we need to create a function that will encode the offchain content into cells using this functions:

export function encodeOffChainContent(content: string) {
  let data = Buffer.from(content);
  const offChainPrefix = Buffer.from([0x01]);
  data = Buffer.concat([offChainPrefix, data]);
  return makeSnakeCell(data);
}

🚢 Deploy NFT collection
Once our metadata is ready and uploaded to IPFS, we can proceed with deploying our collection!

We will create a file to store all logic related to our collection in /contracts/NftCollection.ts. As always, we start with imports:

import {
  Address,
  Cell,
  internal,
  beginCell,
  contractAddress,
  StateInit,
  SendMode,
} from "@ton/core";
import { encodeOffChainContent, OpenedWallet } from "../utils";

Next, we declare a type that describes the initial data required for our collection:

export type collectionData = {
  ownerAddress: Address;
  royaltyPercent: number;
  royaltyAddress: Address;
  nextItemIndex: number;
  collectionContentUrl: string;
  commonContentUrl: string;
}

Name	Explanation
ownerAddress	The address set as the collection owner. Only the owner can mint new NFTs
royaltyPercent	The percentage of each sale that goes to the specified address
royaltyAddress	The wallet address that receives royalties from sales of this NFT collection
nextItemIndex	The index assigned to the next NFT item
collectionContentUrl	The URL of the collection metadata
commonContentUrl	he base URL for NFT item metadata
First, let's write a private method that returns a cell containing our collection's code.

export class NftCollection {
  private collectionData: collectionData;

  constructor(collectionData: collectionData) {
    this.collectionData = collectionData;
  }

  private createCodeCell(): Cell {
    const NftCollectionCodeBoc =
      "te6cckECFAEAAh8AART/APSkE/S88sgLAQIBYgkCAgEgBAMAJbyC32omh9IGmf6mpqGC3oahgsQCASAIBQIBIAcGAC209H2omh9IGmf6mpqGAovgngCOAD4AsAAvtdr9qJofSBpn+pqahg2IOhph+mH/SAYQAEO4tdMe1E0PpA0z/U1NQwECRfBNDUMdQw0HHIywcBzxbMyYAgLNDwoCASAMCwA9Ra8ARwIfAFd4AYyMsFWM8WUAT6AhPLaxLMzMlx+wCAIBIA4NABs+QB0yMsCEsoHy//J0IAAtAHIyz/4KM8WyXAgyMsBE/QA9ADLAMmAE59EGOASK3wAOhpgYC42Eit8H0gGADpj+mf9qJofSBpn+pqahhBCDSenKgpQF1HFBuvgoDoQQhUZYBWuEAIZGWCqALnixJ9AQpltQnlj+WfgOeLZMAgfYBwGyi544L5cMiS4ADxgRLgAXGBEuAB8YEYGYHgAkExIREAA8jhXU1DAQNEEwyFAFzxYTyz/MzMzJ7VTgXwSED/LwACwyNAH6QDBBRMhQBc8WE8s/zMzMye1UAKY1cAPUMI43gED0lm+lII4pBqQggQD6vpPywY/egQGTIaBTJbvy9AL6ANQwIlRLMPAGI7qTAqQC3gSSbCHis+YwMlBEQxPIUAXPFhPLP8zMzMntVABgNQLTP1MTu/LhklMTugH6ANQwKBA0WfAGjhIBpENDyFAFzxYTyz/MzMzJ7VSSXwXiN0CayQ==";
    return Cell.fromBase64(NftCollectionCodeBoc);
  }
}


In this method, we simply read the cell from the base64 representation of the collection smart contract.

Now, we need to create the cell containing our collection’s initial data. Essentially, we must store collectionData correctly. First, we create an empty cell and store the collection owner's address and the index of the next item to be minted. Let’s define the next private method:

private createDataCell(): Cell {
  const data = this.collectionData;
  const dataCell = beginCell();

  dataCell.storeAddress(data.ownerAddress);
  dataCell.storeUint(data.nextItemIndex, 64);

Next, we create an empty cell to store the collection’s content. We then store a reference to the encoded content cell within our main data cell.

const contentCell = beginCell();

const collectionContent = encodeOffChainContent(data.collectionContentUrl);

const commonContent = beginCell();
commonContent.storeBuffer(Buffer.from(data.commonContentUrl));

contentCell.storeRef(collectionContent);
contentCell.storeRef(commonContent.asCell());
dataCell.storeRef(contentCell);


After that, we create a cell containing the NFT item code and store a reference to this cell in dataCell.

const NftItemCodeCell = Cell.fromBase64(
  "te6cckECDQEAAdAAART/APSkE/S88sgLAQIBYgMCAAmhH5/gBQICzgcEAgEgBgUAHQDyMs/WM8WAc8WzMntVIAA7O1E0NM/+kAg10nCAJp/AfpA1DAQJBAj4DBwWW1tgAgEgCQgAET6RDBwuvLhTYALXDIhxwCSXwPg0NMDAXGwkl8D4PpA+kAx+gAxcdch+gAx+gAw8AIEs44UMGwiNFIyxwXy4ZUB+kDUMBAj8APgBtMf0z+CEF/MPRRSMLqOhzIQN14yQBPgMDQ0NTWCEC/LJqISuuMCXwSED/LwgCwoAcnCCEIt3FzUFyMv/UATPFhAkgEBwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7AAH2UTXHBfLhkfpAIfAB+kDSADH6AIIK+vCAG6EhlFMVoKHeItcLAcMAIJIGoZE24iDC//LhkiGOPoIQBRONkchQCc8WUAvPFnEkSRRURqBwgBDIywVQB88WUAX6AhXLahLLH8s/Im6zlFjPFwGRMuIByQH7ABBHlBAqN1viDACCAo41JvABghDVMnbbEDdEAG1xcIAQyMsFUAfPFlAF+gIVy2oSyx/LPyJus5RYzxcBkTLiAckB+wCTMDI04lUC8ANqhGIu"
);
dataCell.storeRef(NftItemCodeCell);


The smart contract stores royalty parameters using royaltyFactor, royaltyBase, and royaltyAddress. The royalty percentage is calculated using the formula: 
(
royaltyFactor
royaltyBase
)
×
100
%
( 
royaltyBase
royaltyFactor
​
 )×100% . If we know royaltyPercent, calculating royaltyFactor is straightforward.

const royaltyBase = 1000;
const royaltyFactor = Math.floor(data.royaltyPercent * royaltyBase);

After performing these calculations, we store the royalty data in a separate cell and reference it in dataCell.

const royaltyCell = beginCell();
royaltyCell.storeUint(royaltyFactor, 16);
royaltyCell.storeUint(royaltyBase, 16);
royaltyCell.storeAddress(data.royaltyAddress);
dataCell.storeRef(royaltyCell);

return dataCell.endCell();
}

Now, let's write a getter that returns the StateInit of our collection.

public get stateInit(): StateInit {
  const code = this.createCodeCell();
  const data = this.createDataCell();

  return { code, data };
}

We also need a getter that calculates the collection’s address. In TON, a smart contract’s address is simply the hash of its StateInit.

public get address(): Address {
    return contractAddress(0, this.stateInit);
  }

The final step is writing a method to deploy the smart contract to the blockchain!

public async deploy(wallet: OpenedWallet) {
    const seqno = await wallet.contract.getSeqno();
    await wallet.contract.sendTransfer({
      seqno,
      secretKey: wallet.keyPair.secretKey,
      messages: [
        internal({
          value: "0.05",
          to: this.address,
          init: this.stateInit,
        }),
      ],
      sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,
    });
    return seqno;
  }

Deploying a new smart contract in our case means sending a message from our wallet to the collection address, which we can calculate if we have StateInit, along with its StateInit. When the owner mints a new NFT, the collection accepts the owner's message and sends a new message to the created NFT smart contract, which requires a fee. Let’s write a method to replenish the collection’s balance based on the number of NFTs to be minted:

public async topUpBalance(
    wallet: OpenedWallet,
    nftAmount: number
  ): Promise<number> {
    const feeAmount = 0.026 // approximate value of fees for 1 transaction in our case 
    const seqno = await wallet.contract.getSeqno();
    const amount = nftAmount * feeAmount;

    await wallet.contract.sendTransfer({
      seqno,
      secretKey: wallet.keyPair.secretKey,
      messages: [
        internal({
          value: amount.toString(),
          to: this.address.toString({ bounceable: false }),
          body: new Cell(),
        }),
      ],
      sendMode: SendMode.PAY_GAS_SEPARATELY + SendMode.IGNORE_ERRORS,
    });

    return seqno;
  }


Now, let’s add a few include statements to app.ts:

import { waitSeqno } from "./delay";
import { NftCollection } from "./contracts/NftCollection";

Finally, we add a few lines to the end of the init() function to deploy the new collection:

console.log("Start deploy of nft collection...");
const collectionData = {
  ownerAddress: wallet.contract.address,
  royaltyPercent: 0.05, // 0.05 = 5%
  royaltyAddress: wallet.contract.address,
  nextItemIndex: 0,
  collectionContentUrl: `ipfs://${metadataIpfsHash}/collection.json`,
  commonContentUrl: `ipfs://${metadataIpfsHash}/`,
};
const collection = new NftCollection(collectionData);
let seqno = await collection.deploy(wallet);
console.log(`Collection deployed: ${collection.address}`);
await waitSeqno(seqno, wallet);

🚢 Deploy NFT items
Once our collection is ready, we can start minting our NFTs! We will store the code in src/contracts/NftItem.ts

Unexpectedly, we need to return to NftCollection.ts and add the following type near collectionData at the top of the file.

export type mintParams = {
  queryId: number | null,
  itemOwnerAddress: Address,
  itemIndex: number,
  amount: bigint,
  commonContentUrl: string
}

Name	Explanation
itemOwnerAddress	The address set as the item's owner
itemIndex	The index of the NFT item
amount	The amount of TON sent to the NFT upon deployment
commonContentUrl	The full link to the item URL, which is "commonContentUrl" of the collection + this commonContentUrl
Next, we create a method in the NftCollection class to construct the body for deploying an NFT item. First, we store a bit to indicate to the collection smart contract that we want to create a new NFT. Then, we store the queryId and the index of the NFT item.

public createMintBody(params: mintParams): Cell {
    const body = beginCell();
    body.storeUint(1, 32);
    body.storeUint(params.queryId || 0, 64);
    body.storeUint(params.itemIndex, 64);
    body.storeCoins(params.amount);

After that, we create an empty cell and store the owner's address:

    const nftItemContent = beginCell();
    nftItemContent.storeAddress(params.itemOwnerAddress);

We store a reference in this cell (containing the NFT item content) to the item's metadata.

    const uriContent = beginCell();
    uriContent.storeBuffer(Buffer.from(params.commonContentUrl));
    nftItemContent.storeRef(uriContent.endCell());

We store a reference to the cell with the item content in our body cell.

    body.storeRef(nftItemContent.endCell());
    return body.endCell();
}

Now, we return to NftItem.ts. The only step left is to send a message to our collection contract with the body of our NFT.

import { internal, SendMode, Address, beginCell, Cell, toNano } from "@ton/core";
import { OpenedWallet } from "utils";
import { NftCollection, mintParams } from "./NftCollection";
import { TonClient } from "@ton/ton";

export class NftItem {
  private collection: NftCollection;

  constructor(collection: NftCollection) {
    this.collection = collection;
  }

  public async deploy(
    wallet: OpenedWallet,
    params: mintParams
  ): Promise<number> {
    const seqno = await wallet.contract.getSeqno();
    await wallet.contract.sendTransfer({
      seqno,
      secretKey: wallet.keyPair.secretKey,
      messages: [
        internal({
          value: "0.05",
          to: this.collection.address,
          body: this.collection.createMintBody(params),
        }),
      ],
      sendMode: SendMode.IGNORE_ERRORS + SendMode.PAY_GAS_SEPARATELY,
    });
    return seqno;
  }
}


At the end, we write a short method to retrieve an NFT’s address by its index:

Create a client variable to call the collection’s get-method.

static async getAddressByIndex(
  collectionAddress: Address,
  itemIndex: number
): Promise<Address> {
  const client = new TonClient({
    endpoint: "https://testnet.toncenter.com/api/v2/jsonRPC",
    apiKey: process.env.TONCENTER_API_KEY,
  });

Call the get-method to return the NFT address based on its index.

  const response = await client.runMethod(
    collectionAddress,
    "get_nft_address_by_index",
    [{ type: "int", value: BigInt(itemIndex) }]
  );

Parse the returned address.

    return response.stack.readAddress();
}

Now, let's add some code to app.ts to automate the NFT minting process:

  import { NftItem } from "./contracts/NftItem";
  import { toNano } from '@ton/core';

First, read all files in the metadata folder.

const files = await readdir(metadataFolderPath);
files.pop();
let index = 0;

Next, top up the collection’s balance.

seqno = await collection.topUpBalance(wallet, files.length);
await waitSeqno(seqno, wallet);
console.log(`Balance top-upped`);

Finally, iterate through each metadata file, create an NftItem instance, and call the deploy method. After that, wait until the seqno increases.

for (const file of files) {
    console.log(`Start deploy of ${index + 1} NFT`);
    const mintParams = {
      queryId: 0,
      itemOwnerAddress: wallet.contract.address,
      itemIndex: index,
      amount: toNano("0.05"),
      commonContentUrl: file,
    };

    const nftItem = new NftItem(collection);
    seqno = await nftItem.deploy(wallet, mintParams);
    console.log(`Successfully deployed ${index + 1} NFT`);
    await waitSeqno(seqno, wallet);
    index++;
  }

🏷 Put the NFT on sale
To list an NFT for sale, we need two smart contracts:

Marketplace - Handles the logic for creating new sales.
Sale contract - Manages the logic for buying and canceling sales.
Deploy the marketplace
Create a new file: /contracts/NftMarketplace.ts. Create a basic class that accepts the marketplace owner’s address and generates a cell with the smart contract code and initial data (we will use basic version of NFT-Marketplace smart contract).

import {
  Address,
  beginCell,
  Cell,
  contractAddress,
  internal,
  SendMode,
  StateInit,
} from "@ton/core";
import { OpenedWallet } from "../utils";

export class NftMarketplace {
  public ownerAddress: Address;

  constructor(ownerAddress: Address) {
    this.ownerAddress = ownerAddress;
  }


  public get stateInit(): StateInit {
    const code = this.createCodeCell();
    const data = this.createDataCell();

    return { code, data };
  }

  private createDataCell(): Cell {
    const dataCell = beginCell();

    dataCell.storeAddress(this.ownerAddress);

    return dataCell.endCell();
  }

  private createCodeCell(): Cell {
    const NftMarketplaceCodeBoc = "te6cckEBBAEAbQABFP8A9KQT9LzyyAsBAgEgAgMAqtIyIccAkVvg0NMDAXGwkVvg+kDtRND6QDASxwXy4ZEB0x8BwAGOK/oAMAHU1DAh+QBwyMoHy//J0Hd0gBjIywXLAljPFlAE+gITy2vMzMlx+wCRW+IABPIwjvfM5w==";
    return Cell.fromBase64(NftMarketplaceCodeBoc)
  }
}


Implement a method to calculate the smart contract address based on StateInit.

public get address(): Address {
    return contractAddress(0, this.stateInit);
  }

Write a method to deploy the marketplace.

public async deploy(wallet: OpenedWallet): Promise<number> {
    const seqno = await wallet.contract.getSeqno();
    await wallet.contract.sendTransfer({
      seqno,
      secretKey: wallet.keyPair.secretKey,
      messages: [
        internal({
          value: "0.5",
          to: this.address,
          init: this.stateInit,
        }),
      ],
      sendMode: SendMode.IGNORE_ERRORS + SendMode.PAY_GAS_SEPARATELY,
    });
    return seqno;
  }

The deployment process is similar to other smart contracts (such as NftItem or a new collection). However, we initially fund the marketplace with 0.5 TON instead of 0.05 TON. Why? When deploying a new sales contract, the marketplace processes the request and sends a message to the new contract. Since this process involves additional transaction fees, we need extra TON.

Finally, add a few lines of code to app.ts to deploy the marketplace.

import { NftMarketplace } from "./contracts/NftMarketplace";

Then:

console.log("Start deploy of new marketplace  ");
const marketplace = new NftMarketplace(wallet.contract.address);
seqno = await marketplace.deploy(wallet);
await waitSeqno(seqno, wallet);
console.log("Successfully deployed new marketplace");

Deploying the sale contract
Now, we can deploy the NFT sale smart contract. How does it work?Transfer the NFT to the sale contract by changing its owner in the item data. In this tutorial, we will use nft-fixprice-sale-v2 smart contract.

Create a new file: /contracts/NftSale.ts. Declare a type that describes the sale contract data.

import {
  Address,
  beginCell,
  Cell,
  contractAddress,
  internal,
  SendMode,
  StateInit,
  storeStateInit,
  toNano,
} from "@ton/core";
import { OpenedWallet } from "utils";

export type GetGemsSaleData = {
  isComplete: boolean;
  createdAt: number;
  marketplaceAddress: Address;
  nftAddress: Address;
  nftOwnerAddress: Address | null;
  fullPrice: bigint;
  marketplaceFeeAddress: Address;
  marketplaceFee: bigint;
  royaltyAddress: Address;
  royaltyAmount: bigint;
};

Create a class and a method to generate the initial data cell for the smart contract.

export class NftSale {
  private data: GetGemsSaleData;

  constructor(data: GetGemsSaleData) {
    this.data = data;
  }
}

We will begin with creating a cell with fee details:

The address receiving the marketplace fee.
The TON amount sent as a marketplace fee.
The address receiving the royalty from the sale.
The royalty amount.
private createDataCell(): Cell {
  const saleData = this.data;

  const feesCell = beginCell();

  feesCell.storeAddress(saleData.marketplaceFeeAddress);
  feesCell.storeCoins(saleData.marketplaceFee);
  feesCell.storeAddress(saleData.royaltyAddress);
  feesCell.storeCoins(saleData.royaltyAmount);

Following that we can create an empty cell and just store information from saleData in the correct order. Right after that, store the reference to the cell with the fees information:

  const dataCell = beginCell();

  dataCell.storeUint(saleData.isComplete ? 1 : 0, 1);
  dataCell.storeUint(saleData.createdAt, 32);
  dataCell.storeAddress(saleData.marketplaceAddress);
  dataCell.storeAddress(saleData.nftAddress);
  dataCell.storeAddress(saleData.nftOwnerAddress);
  dataCell.storeCoins(saleData.fullPrice);
  dataCell.storeRef(feesCell.endCell());

  return dataCell.endCell();
}

And as always, add methods to get stateInit, the initial code cell, and the smart contract address.

public get address(): Address {
  return contractAddress(0, this.stateInit);
}

public get stateInit(): StateInit {
  const code = this.createCodeCell();
  const data = this.createDataCell();

  return { code, data };
}

private createCodeCell(): Cell {
  const NftFixPriceSaleV2CodeBoc =
    "te6cckECDAEAAikAART/APSkE/S88sgLAQIBIAMCAATyMAIBSAUEAFGgOFnaiaGmAaY/9IH0gfSB9AGoYaH0gfQB9IH0AGEEIIySsKAVgAKrAQICzQgGAfdmCEDuaygBSYKBSML7y4cIk0PpA+gD6QPoAMFOSoSGhUIehFqBSkHCAEMjLBVADzxYB+gLLaslx+wAlwgAl10nCArCOF1BFcIAQyMsFUAPPFgH6AstqyXH7ABAjkjQ04lpwgBDIywVQA88WAfoCy2rJcfsAcCCCEF/MPRSBwCCIYAYyMsFKs8WIfoCy2rLHxPLPyPPFlADzxbKACH6AsoAyYMG+wBxVVAGyMsAFcsfUAPPFgHPFgHPFgH6AszJ7VQC99AOhpgYC42EkvgnB9IBh2omhpgGmP/SB9IH0gfQBqGBNgAPloyhFrpOEBWccgGRwcKaDjgskvhHAoomOC+XD6AmmPwQgCicbIiV15cPrpn5j9IBggKwNkZYAK5Y+oAeeLAOeLAOeLAP0BZmT2qnAbE+OAcYED6Y/pn5gQwLCQFKwAGSXwvgIcACnzEQSRA4R2AQJRAkECPwBeA6wAPjAl8JhA/y8AoAyoIQO5rKABi+8uHJU0bHBVFSxwUVsfLhynAgghBfzD0UIYAQyMsFKM8WIfoCy2rLHxnLPyfPFifPFhjKACf6AhfKAMmAQPsAcQZQREUVBsjLABXLH1ADzxYBzxYBzxYB+gLMye1UABY3EDhHZRRDMHDwBTThaBI=";

  return Cell.fromBase64(NftFixPriceSaleV2CodeBoc);
}


To deploy the sale contract, we must form a message and send it to the marketplace:

First, create a cell storing the StateInit of the new sale contract

public async deploy(wallet: OpenedWallet): Promise<number> {
    const stateInit = beginCell()
      .store(storeStateInit(this.stateInit))
      .endCell();

Create a cell with the message body.

Set op-code = 1 to indicate a new sale contract deployment.
Store the coins sent to the new sale contract.
Store two references: StateInit of the new contract; the body sent to the new contract.
Send the message to deploy the contract.
  const payload = beginCell();
  payload.storeUint(1, 32);
  payload.storeCoins(toNano("0.05"));
  payload.storeRef(stateInit);
  payload.storeRef(new Cell());

Finally, let's send our message:

  const seqno = await wallet.contract.getSeqno();
  await wallet.contract.sendTransfer({
    seqno,
    secretKey: wallet.keyPair.secretKey,
    messages: [
      internal({
        value: "0.05",
        to: this.data.marketplaceAddress,
        body: payload.endCell(),
      }),
    ],
    sendMode: SendMode.IGNORE_ERRORS + SendMode.PAY_GAS_SEPARATELY,
  });
  return seqno;
}

Once the sale contract is deployed, the only step left is to transfer ownership of the NFT item to the sale contract’s address.

Transferring the item
Transferring an item means sending a message from the owner’s wallet to the smart contract with the new owner's information.

Go to NftItem.ts and create a new static method in NftItem class to construct the transfer message body:

Create an empty cell and populate it with data.

static createTransferBody(params: {
    newOwner: Address;
    responseTo?: Address;
    forwardAmount?: bigint;
  }): Cell {
    const msgBody = beginCell();
    msgBody.storeUint(0x5fcc3d14, 32); // op-code 
    msgBody.storeUint(0, 64); // query-id
    msgBody.storeAddress(params.newOwner);

Include the following details:

Op-code, query-id, and the new owner's address.
The address where a confirmation response will be sent.
The remaining incoming message coins.
The amount of TON sent to the new owner.
Whether the recipient will receive a text payload.
  msgBody.storeAddress(params.responseTo || null);
  msgBody.storeBit(false); // no custom payload
  msgBody.storeCoins(params.forwardAmount || 0);
  msgBody.storeBit(0); // no forward_payload 

  return msgBody.endCell();
}

Create a transfer function to execute the NFT transfer.

static async transfer(
    wallet: OpenedWallet,
    nftAddress: Address,
    newOwner: Address
  ): Promise<number> {
    const seqno = await wallet.contract.getSeqno();

    await wallet.contract.sendTransfer({
      seqno,
      secretKey: wallet.keyPair.secretKey,
      messages: [
        internal({
          value: "0.05",
          to: nftAddress,
          body: this.createTransferBody({
            newOwner,
            responseTo: wallet.contract.address,
            forwardAmount: toNano("0.02"),
          }),
        }),
      ],
      sendMode: SendMode.IGNORE_ERRORS + SendMode.PAY_GAS_SEPARATELY,
    });
    return seqno;
  }

Nice, we are almost done! Go back to app.ts and retrieve the address of the NFT we want to sell:

const nftToSaleAddress = await NftItem.getAddressByIndex(collection.address, 0);


Create a variable to store sale information.

At beggining of the app.ts, add:

import { GetGemsSaleData, NftSale } from "./contracts/NftSale";

And then:

const saleData: GetGemsSaleData = {
  isComplete: false,
  createdAt: Math.ceil(Date.now() / 1000),
  marketplaceAddress: marketplace.address,
  nftAddress: nftToSaleAddress,
  nftOwnerAddress: null,
  fullPrice: toNano("10"),
  marketplaceFeeAddress: wallet.contract.address,
  marketplaceFee: toNano("1"),
  royaltyAddress: wallet.contract.address,
  royaltyAmount: toNano("0.5"),
};

Note, that you set nftOwnerAddress to null. This ensures that the sale contract accepts coins upon deployment.

Deploy our sale:

const nftSaleContract = new NftSale(saleData);
seqno = await nftSaleContract.deploy(wallet);
await waitSeqno(seqno, wallet);

... and transfer it!

await NftItem.transfer(wallet, nftToSaleAddress, nftSaleContract.address);

Finally, we can launch our project and enjoy the process!

yarn start

Go to https://testnet.getgems.io/collection/{YOUR_COLLECTION_ADDRESS_HERE} and look to this perfect ducks!

Conclusion
Today, you learned a lot about TON and successfully created your own NFT collection on the testnet! If you have any questions or spot an error, feel free to contact the author: @coalus

TEP: 62
title: NFT Standard
status: Active
type: Contract Interface
authors: EmelyanenkoK, Tolya
created: 01.02.2022
replaces: -
replaced by: -
Summary
A standard interface for non-fungible tokens.

Motivation
A standard interface will greatly simplify interaction and display of different entities representing right of ownership.

NFT standard describes:

The way of ownership changing.
The way of association of items into collections.
The way of deduplication of common part of collection.
Guide
Non-Fungible Token (NFT) represents an ownership over unique digital asset (kitten images, title deeds, artworks, etc). Each separate token is an NFT Item. It is also convenient to gather NFT Items into an NFT Collection. In TON, each NFT Item and NFT Collection are separate smart contracts.

NFT Metadata
Main article: TEP-64

Each NFT Item and NFT Collection itself has its own metadata (TEP-64). It contains some info about NFT, such as title and associated image. Metadata can be stored offchain (smart contract will contain only a link to json) or onchain (all data will be stored in smart contract).

Collection metadata example (offchain):

{
   "image": "https://ton.org/_next/static/media/smart-challenge1.7210ca54.png",
   "name": "TON Smart Challenge #2",
   "description": "TON Smart Challenge #2 Winners Trophy",
   "social_links": []
}
Item metadata example (offchain):

{
   "name": "TON Smart Challenge #2 Winners Trophy",
   "description": "TON Smart Challenge #2 Winners Trophy 1 place out of 181",
   "image": "https://ton.org/_next/static/media/duck.d936efd9.png",
   "content_url": "https://ton.org/_next/static/media/dimond_1_VP9.29bcaf8e.webm",
   "attributes": []
}
Offchain metadata is published for example on web.

Useful links
Reference NFT implementation
Getgems NFT contracts
Toncli NFT scaffolding project by Disintar
TON NFT Deployer
FunC Lesson - NFT Standard (en/ru)
TON NFT Explorer
Specification
The NFT collection and each NFT item are separate smart contracts.

Example: if you release a collection that contains 10 000 items, then you will deploy 10 001 smart contracts.

NFT item smart contract
Must implement:

Internal message handlers
1. transfer
Request

TL-B schema of inbound message:

transfer#5fcc3d14 query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell) forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell) = InternalMsgBody;

query_id - arbitrary request number.

new_owner - address of the new owner of the NFT item.

response_destination - address where to send a response with confirmation of a successful transfer and the rest of the incoming message coins.

custom_payload - optional custom data.

forward_amount - the amount of nanotons to be sent to the new owner.

forward_payload - optional custom data that should be sent to the new owner.

Should be rejected if:

message is not from current owner.
there is no enough coins (with respect to NFT own storage fee guidelines) to process operation and send forward_amount.
After processing the request, the contract must send at least in_msg_value - forward_amount - max_tx_gas_price to the response_destination address. If the contract cannot guarantee this, it must immediately stop executing the request and throw error. max_tx_gas_price is the price in Toncoins of maximum transaction gas limit of NFT habitat workchain. For the basechain it can be obtained from ConfigParam 21 from gas_limit field.
Otherwise should do:

change current owner of NFT to new_owner address.
if forward_amount > 0 send message to new_owner address with forward_amount nanotons attached and with the following layout: TL-B schema: ownership_assigned#05138d91 query_id:uint64 prev_owner:MsgAddress forward_payload:(Either Cell ^Cell) = InternalMsgBody; query_id should be equal with request's query_id. forward_payload should be equal with request's forward_payload. prev_owner is address of the previous owner of this NFT item. If forward_amount is equal to zero, notification message should not be sent.
Send all excesses of incoming message coins to response_destination with the following layout: TL-B schema: excesses#d53276db query_id:uint64 = InternalMsgBody; query_id should be equal with request's query_id.
forward_payload format
If you want to send a simple comment in the forward_payload then the forward_payload must starts with 0x00000000 (32-bits unsigned integer equals to zero) and the comment is contained in the remainder of the forward_payload.

If comment does not begin with the byte 0xff, the comment is a text one; it can be displayed "as is" to the end user of a wallet (after filtering invalid and control characters and checking that it is a valid UTF-8 string). For instance, users may indicate the purpose ("for coffee") of a simple transfer from their wallet to the wallet of another user in this text field.

On the other hand, if the comment begins with the byte 0xff, the remainder is a "binary comment", which should not be displayed to the end user as text (only as hex dump if necessary). The intended use of "binary comments" is, e.g., to contain a purchase identifier for payments in a store, to be automatically generated and processed by the store's software.

If the forward_payload contains a binary message for interacting with the destination smart contract (for example, with DEX), then there are no prefixes.

These rules are the same with the payload format when simply sending Toncoins from a regular wallet (Smart Contract Guidelines: Internal Messages, 3).

2 get_static_data
Request

TL-B schema of inbound message:

get_static_data#2fcb26a2 query_id:uint64 = InternalMsgBody;

query_id - arbitrary request number.

should do:

Send back message with the following layout and send-mode 64 (return msg amount except gas fees): TL-B schema: report_static_data#8b771735 query_id:uint64 index:uint256 collection:MsgAddress = InternalMsgBody; query_id should be equal with request's query_id. index - numerical index of this NFT in the collection, usually serial number of deployment. collection - address of the smart contract of the collection to which this NFT belongs.
Get-methods
get_nft_data() returns (int init?, int index, slice collection_address, slice owner_address, cell individual_content) init? - if not zero, then this NFT is fully initialized and ready for interaction. index - numerical index of this NFT in the collection. For collection-less NFT - arbitrary but constant value. collection_address - (MsgAddress) address of the smart contract of the collection to which this NFT belongs. For collection-less NFT this parameter should be addr_none; owner_address - (MsgAddress) address of the current owner of this NFT. individual_content - if NFT has collection - individual NFT content in any format; if NFT has no collection - NFT content in format that complies with standard TEP-64.
NFT Collection smart contract
It is assumed that the smart contract of the collection deploys smart contracts of NFT items of this collection.

Must implement:

Get-methods
get_collection_data() returns (int next_item_index, cell collection_content, slice owner_address) next_item_index - the count of currently deployed NFT items in collection. Generally, collection should issue NFT with sequential indexes (see Rationale(2) ). -1 value of next_item_index is used to indicate non-sequential collections, such collections should provide their own way for index generation / item enumeration. collection_content - collection content in a format that complies with standard TEP-64. owner_address - collection owner address, zero address if no owner.
get_nft_address_by_index(int index) returns slice address Gets the serial number of the NFT item of this collection and returns the address (MsgAddress) of this NFT item smart contract.
get_nft_content(int index, cell individual_content) returns cell full_content Gets the serial number of the NFT item of this collection and the individual content of this NFT item and returns the full content of the NFT item in format that complies with standard TEP-64. As an example, if an NFT item stores a metadata URI in its content, then a collection smart contract can store a domain (e.g. "https://site.org/"), and an NFT item smart contract in its content will store only the individual part of the link (e.g "kind-cobra"). In this example the get_nft_content method concatenates them and return "https://site.org/kind-cobra".
Drawbacks
There is no way to get current owner of NFT onchain because TON is an asynchronous blockchain. When the message with info about NFT owner will be delivered, this info may become irrelevant, so we can't guarantee that current owner hasn't changed.

Rationale and alternatives
"One NFT - one smart contract" simplifies fees calculation and allows to give gas-consumption guarantees.
NFT collection with sequential NFT index provide easy way of association and search of linked NFTs.
Division of NFT content into individual and common (collection) part allows to deduplicate storage as well as cheap mass update.
Why not a single smart contract with a token_id -> owner_address dictionary?
Unpredictable gas consumption In TON, gas consumption for dictionary operations depends on exact set of keys. Also, TON is an asynchronous blockchain. This means that if you send a message to a smart contract, then you do not know how many messages from other users will reach the smart contract before your message. Thus, you do not know what the size of the dictionary will be at the moment when your message reaches the smart contract. This is OK with a simple wallet -> NFT smart contract interaction, but not acceptable with smart contract chains, e.g. wallet -> NFT smart contract -> auction -> NFT smart contract. If we cannot predict gas consumption, then a situation may occur like that the owner has changed on the NFT smart contract, but there were no enough Toncoins for the auction operation. Using smart contracts without dictionaries gives deterministic gas consumption.
Does not scale (becomes a bottleneck) Scaling in TON is based on the concept of sharding, i.e. automatic partitioning of the network into shardchains under load. The single big smart contract of the popular NFT contradicts this concept. In this case, many transactions will refer to one single smart contract. The TON architecture provides for sharded smart contracts(see whitepaper), but at the moment they are not implemented.
Why are there no "Approvals"?
TON is an asynchronous blockchain, so some synchronous blockchain approaches are not suitable.

You cannot send the message "is there an approval?" because the response may become irrelevant while the response message is getting to you.

If a synchronous blockchain can check alowance and if everything is OK do transferFrom in one transaction, then in an asynchronous blockchain you will always need to send a transferFrom message at random, and in case of an error, catch the response message and perform rollback actions.

This is a complex and inappropriate approach.

Fortunately, all cases that arose during the discussion can be implemented by a regular transfer with notification of the new owner. In some cases, this will require an additional smart contract.

The case when you want to place NFT on several marketplaces at the same time is solved by creating auction smart contracts that first accept payment, and then NFT is sent to one of auction smart contracts.

Why are there no obligatory royalties to the author from all sales?
In the process of developing this idea, we came to the conclusion that it is possible to guarantee royalties to the author from absolutely any sale on the blockchain only in 1 case:

All transfers must be carried out through an open long-term auction, and other types of transfers are prohibited.

If you want to transfer NFT to yourself to another wallet, then you need to start an auction and win it.

Another variation of this scheme is to make all transfers chargeable.

By prohibiting the free transfer of tokens, we make tokens inconvenient in many cases - the user simply updated the wallet, the user wants to donate NFT, the user wants to send NFT to some smart contract.

Given the poor usability and that NFTs are a general concept and not all of them are created for sale - this approach was rejected.

Prior art
Ethereum NFT Standard (EIP-721)
Polkadot NFT Standard (RMRK)
Cosmos InterNFT Standards
Everscale NFT Standard (TIP-4.1)
Unresolved questions
Owner index is not implemented yet, should we implement it in future standards?
There is no standard methods to perform "safe transfer", which will revert ownership transfer in case of contract execution failure.
Future possibilities
None

Standard extensions
The functionality of the basic NFT standard can be extended:

NFTRoyalty
NFTBounceable (Draft)
NFTEditable (Draft)
NFTUpgradable (Draft)
TL-B schema
nothing$0 {X:Type} = Maybe X;
just$1 {X:Type} value:X = Maybe X;
left$0 {X:Type} {Y:Type} value:X = Either X Y;
right$1 {X:Type} {Y:Type} value:Y = Either X Y;
var_uint$_ {n:#} len:(#< n) value:(uint (len * 8))
         = VarUInteger n;

addr_none$00 = MsgAddressExt;
addr_extern$01 len:(## 9) external_address:(bits len) 
             = MsgAddressExt;
anycast_info$_ depth:(#<= 30) { depth >= 1 }
   rewrite_pfx:(bits depth) = Anycast;
addr_std$10 anycast:(Maybe Anycast) 
   workchain_id:int8 address:bits256  = MsgAddressInt;
addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9) 
   workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
_ _:MsgAddressInt = MsgAddress;
_ _:MsgAddressExt = MsgAddress;

transfer query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:(Maybe ^Cell)  forward_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)  = InternalMsgBody;

ownership_assigned query_id:uint64 prev_owner:MsgAddress forward_payload:(Either Cell ^Cell) = InternalMsgBody;

excesses query_id:uint64 = InternalMsgBody;
get_static_data query_id:uint64 = InternalMsgBody;
report_static_data query_id:uint64 index:uint256 collection:MsgAddress = InternalMsgBody;
Tags were calculated via tlbc as follows (request_flag is equal to 0x7fffffff and response flag is equal to 0x80000000):

crc32('transfer query_id:uint64 new_owner:MsgAddress response_destination:MsgAddress custom_payload:Maybe ^Cell forward_amount:VarUInteger 16 forward_payload:Either Cell ^Cell = InternalMsgBody') = 0x5fcc3d14 & 0x7fffffff = 0x5fcc3d14

crc32('ownership_assigned query_id:uint64 prev_owner:MsgAddress forward_payload:Either Cell ^Cell = InternalMsgBody') = 0x85138d91 & 0x7fffffff = 0x05138d91 

crc32('excesses query_id:uint64 = InternalMsgBody') = 0x553276db | 0x80000000 = 0xd53276db

crc32('get_static_data query_id:uint64 = InternalMsgBody') = 0x2fcb26a2 & 0x7fffffff = 0x2fcb26a2

crc32('report_static_data query_id:uint64 index:uint256 collection:MsgAddress = InternalMsgBody') = 0xb771735 | 0x80000000 = 0x8b771735

Acknowledgements
We are grateful to the Tonwhales developers for collaborating on the current draft of the standard 🤝

Changelog

Getgems NFT contracts
This repository is a collection of contracts for TON blockchain used at getgems.io

Including:
standard NFT, collection, sale & marketplace implementations with tests
SBT implementation with tests
Getgems marketplace contract with tests
Getgems sale contract with tests
Getgems Single-NFT contract with tests
NFT Swap contract with tests
For sale contracts
marketplace royalty: 5% (marketplaceFeeFactor: 5, marketplaceFeeBase: 100)
marketplaceFeeAddress: EQCjk1hh952vWaE9bRguFkAhDAL5jj3xj9p0uPWrFBq_GEMS
marketplaceAddress: EQBYTuYbLf8INxFtD8tQeNk5ZLy-nAX9ahQbG_yl1qQ-GEMS
About EQAIFunA...Q-AR
Не используйте этот контракт https://tonviewer.com/EQAIFunALREOeQ99syMbO6sSzM_Fa1RsPD5TBoS0qVeKQ-AR для выставления нфт на продажу. getgems не несет ответственности за пользователей, которые использую его с целью обмана. Для покупки нфт напрямую из блокчейна необходимо проверять код контракта и правильность заполнения данных контракта.

Do not use https://tonviewer.com/EQAIFunALREOeQ99syMbO6sSzM_Fa1RsPD5TBoS0qVeKQ-AR to put NFTs for sale. getgems is not responsible for users who use it for the purpose of deception. To purchase NFT directly from the blockchain, you need to check the contract code and the correctness of the contract data.

Actual sale contracts supported by getgems.io
nft-auction-v4r1.func
code hash base64(zlp4U06qps7tja/UhtB262CpsNbb+1Nnb2YmScBomVY=)
code hash hex(ce5a78534eaaa6ceed8dafd486d076eb60a9b0d6dbfb53676f662649c0689956)
code boc NftAuctionV4R1CodeBoc NftAuctionV4.source.ts
storage format buildNftAuctionV4R1DataCell NftAuctionV4R1.data.ts
example testnet --
example mainnet https://tonviewer.com/EQAix1SwhToa9J9vw71H8nPTuftz4aVckI4D_RtFy75Kt0Vw
contract description (ru): description-v4-ru.md
nft-fixprice-sale-v4r1.fc
code hash base64(a5WmQYucnSNZBF0edVm41UmuDlBvJMqrWPowyPsf64Y=)
code hash hex(6B95A6418B9C9D2359045D1E7559B8D549AE0E506F24CAAB58FA30C8FB1FEB86)
code boc NftFixPriceSaleV4R1CodeBoc NftFixPriceSaleV4.source.ts
storage format buildNftFixPriceSaleV4R1Data NftFixpriceSaleV3.data.ts:74NftFixPriceSaleV4.data.ts
example testnet https://testnet.tonviewer.com/kQDiSfanFAN3IUZ6wIKy3KHo-inSdWU8oc0BI8TZPYUzNMRJ
example mainnet https://tonviewer.com/EQD2Kivo-msu8dsQNiMkPHMoEfmNA3oU-ZQ_yWejbN9vXmVu
contract description (ru): description-ru.md
nft-fixprice-sale-v3r3.fc
code hash base64(JCIfpXHlQuBVx3vt/b9SfHr0YM/cfzRMRQeHtM+h600=)
code hash hex(24221FA571E542E055C77BEDFDBF527C7AF460CFDC7F344C450787B4CFA1EB4D)
code boc NftFixPriceSaleV3R3CodeBoc NftFixpriceSaleV3.source.ts:29
storage format buildNftFixPriceSaleV3R3DataCell NftFixpriceSaleV3.data.ts:120
example testnet https://testnet.tonviewer.com/EQAPPKyXhe64XiwNNhv3Y1l15v0PWqbOonQDL9s2-8vZPlx9
example mainnet https://tonviewer.com/EQCUn-X9Uhe1EkNRhHGT-Jx0y5RX5nj7MB9WgHi7c04wYNZw
contract description (ru): description-ru.md
nft-auction-v3r3.func
code hash base64(u29ireD+stefqzuK6/CTCvmFU99gCTsgJ/Covxab/Ow=)
code hash hex(bb6f62ade0feb2d79fab3b8aebf0930af98553df60093b2027f0a8bf169bfcec)
code boc NftAuctionV3R3CodeBoc NftAuctionV2.source.ts
storage format buildNftAuctionV3R3DataCell NftAuctionV2.data.ts
example testnet https://testnet.tonviewer.com/kQC_fD_gbAgXsuizLU-5usV4sIuRhotmM3DYIUSkBpFYXwAR
example mainnet https://tonviewer.com/EQCX_PNPUnJ1--3gKTR3jPj9OOJl4iwi132-07Q413vRIqI8
contract description (ru): description-ru.md
nft-offer-v1r3.fc
code hash base64(bl1mf6bvqBh8bQKe/UAVYBIy/S42wpHbw0be2rbcgCQ=)
code hash hex(6E5D667FA6EFA8187C6D029EFD4015601232FD2E36C291DBC346DEDAB6DC8024)
code boc NftOffer.source.ts:13
storage format NftOfferData.ts:116
example mainnet: https://tonviewer.com/EQAPCdspv0uVHTa3ItpR49FlBEaaBKFDz5G8m6fmEyqhyY3J
example testnet: https://testnet.tonviewer.com/0QCueSxg3HIgAJkuyuGZN3N-b88OxSqpECWdEDn-ns2o0ooo
contract description (ru): index-notice-ru.md
Deprecated sale contracts
nft-auction-v3r2.func
code hash base64(G9nFo5v_t6DzQViLXdkrgTqEK_Ze8UEJOCIAzq-Pct8)
code hash hex(1BD9C5A39BFFB7A0F341588B5DD92B813A842BF65EF14109382200CEAF8F72DF)
code boc NftAuctionV2.source.ts:7
storage format NftAuctionV2.data.ts:11
example https://tonviewer.com/EQDQq1YoQr9P9jNSRalcq6_PJjYSJKrsG5zLuvyVp74aoTp7
nft-fixprice-sale-v3r2.fc
code hash base64(3rU7bFdlwebNI4v0e8XoO6WWvcwEsLhM1Qqx5HSgjzE)
code hash hex(DEB53B6C5765C1E6CD238BF47BC5E83BA596BDCC04B0B84CD50AB1E474A08F31)
code boc NftFixpriceSaleV3.source.ts:25
storage format NftFixpriceSaleV3.data.ts:19
example https://tonviewer.com/EQDxTK7_BNQ9Vx7c2NENtvQdNlDs92foEzmjuc48vAoCDt86
nft-fixprice-sale-v3.fc
code hash base64(MgUN-sRPZIZrzIbyzZ4TBf6dyts5WcACI3z7CQLUQyM)
code hash hex(32050DFAC44F64866BCC86F2CD9E1305FE9DCADB3959C002237CFB0902D44323)
code boc NftFixpriceSaleV3.source.ts:20
storage format NftFixpriceSaleV3.data.ts:19
example https://tonviewer.com/EQDhQQWcxuN8MeEm75pOgT3E2XeIUPAhz1Frmy5oufsXED8m
nft-fixprice-sale-v2.fc
code hash base64(gnj0xSM95vvtyWmvUZNEp6m__FRIVtuphqlcC8-Fcck)
code hash hex(8278F4C5233DE6FBEDC969AF519344A7A9BFFC544856DBA986A95C0BCF8571C9)
code boc NftFixpriceSaleV2.source.ts:10
storage format NftFixpriceSaleV2.data.ts:18
example https://tonviewer.com/EQCQJVX5xrOZNo69w6b2SK-D8gTkG8pfEuldIKXM4Kdn2j_U
nft-auction-v2.func
code hash base64(ZmiHL6eXBUQ__UdSPo6eqfdquZ-aC1nSfej4GhwnudQ)
code hash hex(6668872FA79705443FFD47523E8E9EA9F76AB99F9A0B59D27DE8F81A1C27B9D4)
code boc NftAuctionV2.source.ts:3
storage format NftAuctionV2.data.ts:25
example https://tonviewer.com/EQAN1LCxXZtfM1kVrBTcEP1KRRlwNmhOcue6w0NXt6O4trU8

TEP: 74
title: Fungible tokens (Jettons) standard
status: Active
type: Contract Interface
authors: EmelyanenkoK, Tolya
created: 12.03.2022
replaces: -
replaced by: -
Summary
A standard interface for Jettons (TON fungible tokens).

Motivation
A standard interface will greatly simplify interaction and display of different tokenized assets.

Jetton standard describes:

The way of jetton transfers.
The way of retrieving common information (name, circulating supply, etc) about given Jetton asset.
Guide
Useful links
Reference jetton implementation
Jetton deployer
FunC Jetton lesson (en/ru)
Specification
Here and following we use "Jetton" with capital J as designation for entirety of tokens of the same type, while "jetton" with j as designation of amount of tokens of some type.

Jettons are organized as follows: each Jetton has master smart-contract which is used to mint new jettons, account for circulating supply and provide common information.

At the same time information about amount of jettons owned by each user is stores in decentralized manner in individual (for each owner) smart-contracts called "jetton-wallets".

Example: if you release a Jetton with circulating supply of 200 jetton which are owned by 3 people, then you will deploy 4 contracts: 1 Jetton-master and 3 jetton-wallets.

Jetton wallet smart contract
Must implement:

Internal message handlers
1. transfer
Request

TL-B schema of inbound message:

transfer#0f8a7ea5 query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
                 response_destination:MsgAddress custom_payload:(Maybe ^Cell)
                 forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
                 = InternalMsgBody;
query_id - arbitrary request number.

amount - amount of transferred jettons in elementary units.

destination - address of the new owner of the jettons.

response_destination - address where to send a response with confirmation of a successful transfer and the rest of the incoming message Toncoins.

custom_payload - optional custom data (which is used by either sender or receiver jetton wallet for inner logic).

forward_ton_amount - the amount of nanotons to be sent to the destination address.

forward_payload - optional custom data that should be sent to the destination address.

Should be rejected if:

message is not from the owner.
there is no enough jettons on the sender wallet
there is no enough TON (with respect to jetton own storage fee guidelines and operation costs) to process operation, deploy receiver's jetton-wallet and send forward_ton_amount.
After processing the request, the receiver's jetton-wallet must send at least in_msg_value - forward_ton_amount - 2 * max_tx_gas_price - 2 * fwd_fee to the response_destination address. If the sender jetton-wallet cannot guarantee this, it must immediately stop executing the request and throw error. max_tx_gas_price is the price in Toncoins of maximum transaction gas limit of FT habitat workchain. For the basechain it can be obtained from ConfigParam 21 from gas_limit field. fwd_fee is forward fee for transfer request, it can be obtained from parsing transfer request message.
Otherwise should do:

decrease jetton amount on sender wallet by amount and send message which increase jetton amount on receiver wallet (and optionally deploy it).
if forward_amount > 0 ensure that receiver's jetton-wallet send message to destination address with forward_amount nanotons attached and with the following layout: TL-B schema:
transfer_notification#7362d09c query_id:uint64 amount:(VarUInteger 16)
                              sender:MsgAddress forward_payload:(Either Cell ^Cell)
                              = InternalMsgBody;
query_id should be equal with request's query_id.

amount amount of transferred jettons.

sender is address of the previous owner of transferred jettons.

forward_payload should be equal with request's forward_payload.

If forward_amount is equal to zero, notification message should not be sent.

Receiver's wallet should send all excesses of incoming message coins to response_destination with the following layout: TL-B schema: excesses#d53276db query_id:uint64 = InternalMsgBody; query_id should be equal with request's query_id.
forward_payload format
If you want to send a simple comment in the forward_payload then the forward_payload must starts with 0x00000000 (32-bits unsigned integer equals to zero) and the comment is contained in the remainder of the forward_payload.

If comment does not begin with the byte 0xff, the comment is a text one; it can be displayed "as is" to the end user of a wallet (after filtering invalid and control characters and checking that it is a valid UTF-8 string). For instance, users may indicate the purpose ("for coffee") of a simple transfer from their wallet to the wallet of another user in this text field.

On the other hand, if the comment begins with the byte 0xff, the remainder is a "binary comment", which should not be displayed to the end user as text (only as hex dump if necessary). The intended use of "binary comments" is, e.g., to contain a purchase identifier for payments in a store, to be automatically generated and processed by the store's software.

If the forward_payload contains a binary message for interacting with the destination smart contract (for example, with DEX), then there are no prefixes.

These rules are the same with the payload format when simply sending Toncoins from a regular wallet (Smart Contract Guidelines: Internal Messages, 3).

2. burn
Request

TL-B schema of inbound message:

burn#595f07bc query_id:uint64 amount:(VarUInteger 16)
              response_destination:MsgAddress custom_payload:(Maybe ^Cell)
              = InternalMsgBody;
query_id - arbitrary request number.

amount - amount of burned jettons

response_destination - address where to send a response with confirmation of a successful burn and the rest of the incoming message coins.

custom_payload - optional custom data.

Should be rejected if:

message is not from the owner.
there is no enough jettons on the sender wallet
There is no enough TONs to send after processing the request at least in_msg_value -  max_tx_gas_price to the response_destination address. If the sender jetton-wallet cannot guarantee this, it must immediately stop executing the request and throw error.
Otherwise should do:

decrease jetton amount on burner wallet by amount and send notification to jetton master with information about burn.
Jetton master should send all excesses of incoming message coins to response_destination with the following layout: TL-B schema: excesses#d53276db query_id:uint64 = InternalMsgBody; query_id should be equal with request's query_id.
Get-methods
get_wallet_data() returns (int balance, slice owner, slice jetton, cell jetton_wallet_code) balance - (uint256) amount of jettons on wallet. owner - (MsgAddress) address of wallet owner; jetton - (MsgAddress) address of Jetton master-address; jetton_wallet_code - (cell) with code of this wallet;
Jetton master contract
Get-methods
get_jetton_data() returns (int total_supply, int mintable, slice admin_address, cell jetton_content, cell jetton_wallet_code) total_supply - (integer) - the total number of issues jettons mintable - (-1/0) - flag which indicates whether number of jettons can increase admin_address - (MsgAddressInt) - address of smart-contrac which control Jetton jetton_content - cell - data in accordance to Token Data Standard #64 jetton_wallet_code - cell - code of wallet for that jetton
get_wallet_address(slice owner_address) return slice jetton_wallet_address Returns jetton wallet address (MsgAddressInt) for this owner address (MsgAddressInt).
TL-B schema
nothing$0 {X:Type} = Maybe X;
just$1 {X:Type} value:X = Maybe X;
left$0 {X:Type} {Y:Type} value:X = Either X Y;
right$1 {X:Type} {Y:Type} value:Y = Either X Y;
var_uint$_ {n:#} len:(#< n) value:(uint (len * 8))
         = VarUInteger n;

addr_none$00 = MsgAddressExt;
addr_extern$01 len:(## 9) external_address:(bits len)
             = MsgAddressExt;
anycast_info$_ depth:(#<= 30) { depth >= 1 }
   rewrite_pfx:(bits depth) = Anycast;
addr_std$10 anycast:(Maybe Anycast)
   workchain_id:int8 address:bits256  = MsgAddressInt;
addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9)
   workchain_id:int32 address:(bits addr_len) = MsgAddressInt;
_ _:MsgAddressInt = MsgAddress;
_ _:MsgAddressExt = MsgAddress;

transfer query_id:uint64 amount:(VarUInteger 16) destination:MsgAddress
           response_destination:MsgAddress custom_payload:(Maybe ^Cell)
           forward_ton_amount:(VarUInteger 16) forward_payload:(Either Cell ^Cell)
           = InternalMsgBody;

transfer_notification query_id:uint64 amount:(VarUInteger 16)
           sender:MsgAddress forward_payload:(Either Cell ^Cell)
           = InternalMsgBody;

excesses query_id:uint64 = InternalMsgBody;

burn query_id:uint64 amount:(VarUInteger 16)
       response_destination:MsgAddress custom_payload:(Maybe ^Cell)
       = InternalMsgBody;

// ----- Unspecified by standard, but suggested format of internal message

internal_transfer  query_id:uint64 amount:(VarUInteger 16) from:MsgAddress
                     response_address:MsgAddress
                     forward_ton_amount:(VarUInteger 16)
                     forward_payload:(Either Cell ^Cell)
                     = InternalMsgBody;
burn_notification query_id:uint64 amount:(VarUInteger 16)
       sender:MsgAddress response_destination:MsgAddress
       = InternalMsgBody;
crc32('transfer query_id:uint64 amount:VarUInteger 16 destination:MsgAddress response_destination:MsgAddress custom_payload:Maybe ^Cell forward_ton_amount:VarUInteger 16 forward_payload:Either Cell ^Cell = InternalMsgBody') = 0x8f8a7ea5 & 0x7fffffff = 0xf8a7ea5

crc32('transfer_notification query_id:uint64 amount:VarUInteger 16 sender:MsgAddress forward_payload:Either Cell ^Cell = InternalMsgBody') = 0xf362d09c & 0x7fffffff = 0x7362d09c

crc32('excesses query_id:uint64 = InternalMsgBody') = 0x553276db | 0x80000000 = 0xd53276db

crc32('burn query_id:uint64 amount:VarUInteger 16 response_destination:MsgAddress custom_payload:Maybe ^Cell = InternalMsgBody') = 0x595f07bc & 0x7fffffff = 0x595f07bc

crc32('internal_transfer query_id:uint64 amount:VarUInteger 16 from:MsgAddress response_address:MsgAddress forward_ton_amount:VarUInteger 16 forward_payload:Either Cell ^Cell = InternalMsgBody') = 0x978d4519 & 0x7fffffff = 0x178d4519

crc32('burn_notification query_id:uint64 amount:VarUInteger 16 sender:MsgAddress response_destination:MsgAddress = InternalMsgBody') = 0x7bdd97de & 0x7fffffff = 0x7bdd97de

Drawbacks
There is no way to get actual wallet balance onchain, because when the message with balance will arrive, wallet balance may be not actual.

Rationale and alternatives
Distributed architecture "One wallet - one contract" well described in the NFT standard in paragraph "Rationale".

Prior art
EIP-20 Token Standard
Sharded Smart Contracts for Smart Contract Developers
Unresolved questions
There is no standard methods to perform "safe transfer", which will revert ownership transfer in case of contract execution failure.
Future possibilities

TEP: 115
title: TON Connect
status: Active
type: Core
authors: @oleganza, @siandreev, subden, brainpicture, @sorokin0andrey, abogoslavskiy, @MariaBit, Olga May, Aleksei Mazelyuk, tonrostislav, KuznetsovNikita.
created: 20.10.2022
replaces: -
replaced by: -
Summary
TON Connect is a unified protocol for communication between TON wallets and TON apps.

Motivation
The Open Network needs a unified protocol for communication between TON wallets and TON (d)apps to achieve following goals:

Any TON app (web / desktop / mobile / etc) can be operated by any wallet (mobile / desktop / web / browser extension / dapp browser / hardware / etc).

Users get a familiar and friendly experience across all TON apps.

Guide
Apps provide the UI to an infinite range of functionality in TON based on smart contracts, but do not have immediate access to users’ funds. Therefore they are often called decentralized apps or “dapps”.

Wallets provide the UI to approving transactions and hold users’ cryptographic keys securely on their personal devices.

This separation of concerns enables rapid innovation and high level of security for the users: wallets do not need to build walled-garden ecosystems themselves, while the apps do not need to take the risk holding end users’ accounts.

TON Connect is a bridge that crosses this conceptual gap.

TON Connect, in addition to the transport layer of communication between the wallet and the app, provides methods of authorization, sending transactions to the network, interaction with smart contracts, etc.

Specification
Docs and specs are in https://github.com/ton-blockchain/ton-connect repo.

At the time this PR was created (27 Feb, 2023) the revision was acc5dd4d2106891cbfcade8d7faa58b9e16937fd.

Rationale and alternatives
Unified way
Since we strive to make blockchain as convenient and user-friendly as possible, communication between any app and any wallet (mobile wallet or browser extension or something else) must work in a unified way.

This is convenient not only for users, but also for the developers of wallets and developers of dapps, which will need to support only one protocol.

Examples of other blockchains (e.g., Ethereum) that have failed to achieve a single network-wide standard show that this confuses users and makes it difficult for developers: both must understand the different types of wallets and connections.

Sessions for rich dapps
The simplest "one-action" interaction between wallet and dapp can be done with a simple ton:// deeplink, in this variant in general it is not possible to get a response to the request or events in the runtime.

Since rich features are required for more sophisticated dapps, the TON Connect allows to establish permanent connections between the wallet and the application, get responses and events.

SSE
TON Connect uses SSE (Server-Sent Events) protocol instead of websockets, because with websockets in practice there are many connectivity problems that do not have a guaranteed solution.

Backend side
Interaction between wallet and dapp without a backend is possible only for dapp browser or browser extensions with a locally open dapp.

If dapp and wallet are opened on different devices (for example the user opened app on desktop and wallet on mobile) an intermediary is needed for communication (relay or bridge).

Given the previous point about a unified protocol for all types of wallets in the general we need a backend intermediary in TON Connect.

TON Connect uses a simplest bridge for this.

All messages that pass through bridge are encrypted with end-to-end encryption, which preserves the privacy of users.

Dapp browsers and browser extensions can use the JS bridge without the need to run a backend server, while the protocol remains consistent for all types of wallets.

Common public bridge
TON Connect allows to run public bridge(s), which can use any wallets and dapps.

This option is suitable for quick implementation of TON Connect, but has several drawbacks: the public bridge can potentially get the IP addresses of wallet users, some wallets may want extra functionality of the bridge.

Wallets can run and host own bridge
TON Connect allows wallets to run their own bridge if they don't want to use a public bridge.

Each wallet can maintain their own bridge server and are free to choose how to communicate with it.

Dapps don't need to run bridge
In Ton Connect apps do not need to maintain their own backend to receive data from the wallets.

We believe that wallet developers have more possibilities for permanently hosting servers than dapp developers: many dapps are simple serverless web pages. Another argument is that there are many more dapps than wallets.

Open, Free, Decentralized
The unified network-wide standard should be open-source and free.

It is important that it be decentralized, not to depend on a particular server, company or implementation.

As an example, any wallet or dapp should be able to work with this technology without someone else's centralized permission.

TON Connect satisfies these considerations.

We can give an example of the opposite concept of WalletConnect, where all wallets and apps must communicate through a single relay belonging to a particular organization. The possibility of running your own relay (bridge) in WalletConnect is in the plans.

Wallet list
For the convenience of developers it makes sense to create a single config with a list of all the wallets and their info (eg, the bridge address).

Also, for the convenience of the user, UI can display wallets from this list, if the user does not yet have a wallet installed.

Such a list is located in the repository https://github.com/ton-blockchain/wallets-list.

The rules for getting on this list should be simple - the correct technical implementation of TON Connect.

We note that the protocol itself does not depend on this list.

Despite some point of centralization and possible self-regulation issues, such a list would also contribute to the cross-linking and uniformity of the ecosystem.

Future possibilities
Further development of TON Connect is expected in the addition of new RPC methods covering various functionalities.

